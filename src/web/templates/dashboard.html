<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finance Dashboard | Personal Finance Tracker</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%230d6efd'><path d='M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4z'/></svg>">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .dashboard-header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 1.5rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
        }
        .dashboard-header .container {
            position: relative;
            overflow: hidden;
            padding-left: 1rem;
        }
        .dashboard-header h1 {
            font-size: 2.2rem;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: rgba(255,255,255,0.95);
        }
        .dashboard-header p {
            font-size: 1rem;
            opacity: 0.85;
            margin: 0.5rem 0 0 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .dashboard-header .header-icon {
            font-size: 1.8rem;
            color: rgba(255,255,255,0.9);
        }
        .dashboard-header .header-decoration {
            position: absolute;
            right: -50px;
            top: -50px;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0) 70%);
            border-radius: 50%;
            pointer-events: none;
        }
        .dashboard-header .header-decoration:nth-child(2) {
            right: 10%;
            top: -30px;
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(255,255,255,0.03) 0%, rgba(255,255,255,0) 70%);
        }
        .social-links {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        .social-links a {
            color: rgba(255,255,255,0.8);
            font-size: 1.2rem;
            transition: all 0.2s ease;
            text-decoration: none;
        }
        .social-links a:hover {
            color: white;
            transform: translateY(-2px);
        }
        .social-links .divider {
            width: 1px;
            height: 20px;
            background: rgba(255,255,255,0.2);
        }
        .sidebar {
            background-color: #f8f9fa;
            height: 100vh;
            position: sticky;
            top: 0;
            padding-top: 20px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 30px;
            padding: 10px;
        }
        .card {
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            border: none;
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        .card-header {
            background-color: #fff;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            padding: 15px 20px;
        }
        .card-header h5 {
            margin: 0;
            font-weight: 600;
            color: #333;
        }
        .card-body {
            padding: 20px;
        }
        .nav-link {
            color: #495057;
            border-radius: 0;
            padding: 10px 15px;
        }
        .nav-link.active {
            background-color: #e9ecef;
            font-weight: bold;
        }
        .category-badge {
            font-size: 0.9rem;
            margin: 3px;
            padding: 5px 10px;
            display: inline-block;
            border-radius: 0.25rem;
            font-weight: 500;
        }
        .stats-card {
            background-color: #f8f9fa;
            border-left: 4px solid #0d6efd;
            padding: 15px;
            border-radius: 5px;
            transition: transform 0.3s ease;
        }
        .stats-card:hover {
            transform: translateY(-5px);
        }
        .loading-chart {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.8);
            z-index: 10;
            opacity: 1;
            transition: opacity 0.4s ease;
        }
        
        .loading-chart.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #0d6efd;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Amount Filter Styles */
        .amount-filter-error {
            font-size: 0.875rem;
            margin-top: 0.25rem;
            color: #dc3545;
        }

        .form-control.is-invalid {
            border-color: #dc3545;
            padding-right: calc(1.5em + 0.75rem);
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 12' width='12' height='12' fill='none' stroke='%23dc3545'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right calc(0.375em + 0.1875rem) center;
            background-size: calc(0.75em + 0.375rem) calc(0.75em + 0.375rem);
        }

        .amount-filter-second-value {
            transition: all 0.3s ease-in-out;
        }

        .input-group-text {
            background-color: #f8f9fa;
            border-color: #ced4da;
            color: #6c757d;
        }

        .form-control:focus {
            border-color: #86b7fe;
            box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
        }

        .form-control:focus + .input-group-text {
            border-color: #86b7fe;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky">
                    <h4 class="p-3">Finance Tracker</h4>
                    <hr>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link active" href="#overview">Overview</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#transactions">Transactions</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#categories">Categories</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#trends">Trends</a>
                        </li>
                    </ul>
                    <hr>
                    <div class="p-3">
                        <a href="/merchants" class="btn btn-outline-primary btn-sm w-100 mb-2">Merchant Management</a>
                        <a href="/" class="btn btn-outline-secondary btn-sm w-100 mb-2">Back to Home</a>
                        <button id="clear-cache-btn" class="btn btn-outline-danger btn-sm w-100">Clear PDF Cache</button>
                    </div>
                </div>
            </div>

            <!-- Main content -->
            <div class="col-md-9 col-lg-10 ms-sm-auto px-md-4">
                <div class="dashboard-header">
                    <div class="container">
                        <div class="header-decoration"></div>
                        <div class="header-decoration"></div>
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <h1>
                                    <i class="bi bi-graph-up-arrow header-icon"></i>
                                    Finance Dashboard
                                </h1>
                                <p>
                                    <i class="bi bi-bar-chart-line"></i>
                                    Track, analyze, and optimize your financial journey
                                </p>
                            </div>
                            <div class="social-links">
                                <a href="https://github.com/javaidb" target="_blank" title="GitHub Profile">
                                    <i class="bi bi-github"></i>
                                </a>
                                <div class="divider"></div>
                                <a href="https://github.com/javaidb/personal-finance-tracker" target="_blank" title="Project Repository">
                                    <i class="bi bi-code-square"></i>
                                </a>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Overview Section -->
                <section id="overview" class="mb-5">
                    <h2>Overview</h2>
                    <div id="status-message"></div>

                    <div class="row mt-4">
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header">
                                    <h5>Balance Over Time</h5>
                                </div>
                                <div class="card-body">
                                    <div class="chart-container">
                                        <div id="balanceChartLoader" class="loading-chart">
                                            <div class="loading-spinner"></div>
                                        </div>
                                        <canvas id="balanceChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <h5>Financial Milestones</h5>
                                </div>
                                <div class="card-body">
                                    <div class="chart-container">
                                        <div id="milestoneChartLoader" class="loading-chart">
                                            <div class="loading-spinner"></div>
                                        </div>
                                        <canvas id="milestoneChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="row mt-4">
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header">
                                    <h5>Spending by Category</h5>
                                </div>
                                <div class="card-body">
                                    <div class="chart-container">
                                        <div id="categoryChartLoader" class="loading-chart">
                                            <div class="loading-spinner"></div>
                                        </div>
                                        <canvas id="categoryChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header">
                                    <h5>Income by Category</h5>
                                </div>
                                <div class="card-body">
                                    <div class="chart-container">
                                        <div id="incomeChartLoader" class="loading-chart">
                                            <div class="loading-spinner"></div>
                                        </div>
                                        <canvas id="incomeChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Categories Section -->
                <section id="categories" class="mb-5">
                    <h2>Spending Categories</h2>
                    <div class="card mt-4">
                        <div class="card-header">
                            <h5>All Categories</h5>
                        </div>
                        <div class="card-body">
                            <div id="categories-container" class="d-flex flex-wrap gap-2">
                                <!-- Categories will be populated here -->
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Trends Section -->
                <section id="trends" class="mb-5">
                    <h2>Spending Trends</h2>
                    <div class="card mt-4">
                        <div class="card-header">
                            <h5>Monthly Spending Trends</h5>
                        </div>
                        <div class="card-body">
                            <div class="chart-container">
                                <canvas id="trendsChart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <!-- PELT Trend Analysis -->
                    <div class="card mt-4">
                        <div class="card-header">
                            <h5>Balance Trend Analysis (PELT Algorithm)</h5>
                        </div>
                        <div class="card-body">
                            <p class="text-muted mb-3">
                                This chart uses the PELT algorithm to detect significant changes in your balance trend. Vertical lines indicate breakpoints between different financial periods.
                            </p>
                            <div class="chart-container">
                                <canvas id="peltChart"></canvas>
                            </div>
                            <div class="mt-4">
                                <h6>Rate of Change Analysis</h6>
                                <div class="chart-container">
                                    <canvas id="rateOfChangeChart"></canvas>
                                </div>
                                <div class="mt-3">
                                    <small class="text-muted">
                                        <span class="badge bg-success me-1">Green</span> Positive rate (increasing balance)
                                        <span class="badge bg-danger ms-3 me-1">Red</span> Negative rate (decreasing balance)
                                    </small>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Transactions Section -->
                <section id="transactions" class="mb-5">
                    <h2>Recent Transactions</h2>
                    <div class="card mt-4">
                        <div class="card-body">
                            <!-- Date Range Filter -->
                            <div class="row mb-4">
                                <div class="col-md-10">
                                    <div class="row g-3">
                                        <div class="col-md-5">
                                            <label for="start-date" class="form-label">Start Date</label>
                                            <input type="date" id="start-date" class="form-control">
                                        </div>
                                        <div class="col-md-5">
                                            <label for="end-date" class="form-label">End Date</label>
                                            <input type="date" id="end-date" class="form-control">
                                        </div>
                                        <div class="col-md-2 d-flex align-items-end">
                                            <button id="apply-date-filter" class="btn btn-primary">Apply Filter</button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Additional Filters -->
                            <div class="row mb-4">
                                <div class="col-md-10">
                                    <div class="row g-3">
                                        <div class="col-md-3">
                                            <label for="description-search" class="form-label">Search Description</label>
                                            <input type="text" id="description-search" class="form-control" placeholder="Enter keywords...">
                                        </div>
                                        <div class="col-md-3">
                                            <label for="account-type-filter" class="form-label">Account Type</label>
                                            <select id="account-type-filter" class="form-select">
                                                <option value="">All Accounts</option>
                                            </select>
                                        </div>
                                        <div class="col-md-3">
                                            <label for="category-filter" class="form-label">Category</label>
                                            <select id="category-filter" class="form-select">
                                                <option value="">All Categories</option>
                                            </select>
                                        </div>
                                        <div class="col-md-3">
                                            <label class="form-label d-block">Time Range</label>
                                            <div class="btn-group" role="group">
                                                <input type="radio" class="btn-check" name="time-range" id="show-recent" autocomplete="off">
                                                <label class="btn btn-outline-secondary" for="show-recent">Recent (3m)</label>
                                                <input type="radio" class="btn-check" name="time-range" id="show-all" autocomplete="off" checked>
                                                <label class="btn btn-outline-secondary" for="show-all">All Time</label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Amount Filter -->
                            <div class="row mb-4">
                                <div class="col-md-10">
                                    <div class="row g-3">
                                        <div class="col-md-4">
                                            <label for="amount-filter-type" class="form-label">Amount Filter</label>
                                            <select id="amount-filter-type" class="form-select">
                                                <option value="">No Filter</option>
                                                <option value="greater">Greater Than</option>
                                                <option value="less">Less Than</option>
                                                <option value="equal">Equal To</option>
                                                <option value="between">Between</option>
                                            </select>
                                        </div>
                                        <div class="col-md-3">
                                            <label for="amount-filter-value" class="form-label">Amount</label>
                                            <div class="input-group">
                                                <span class="input-group-text">$</span>
                                                <input type="number" id="amount-filter-value" class="form-control" placeholder="0.00" step="0.01" min="0">
                                            </div>
                                        </div>
                                        <div class="col-md-3 amount-filter-second-value" style="display: none;">
                                            <label for="amount-filter-value-2" class="form-label">And</label>
                                            <div class="input-group">
                                                <span class="input-group-text">$</span>
                                                <input type="number" id="amount-filter-value-2" class="form-control" placeholder="0.00" step="0.01" min="0">
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mb-2">
                                <div class="col-md-10">
                                    <button id="reset-filters" class="btn btn-secondary">Reset All Filters</button>
                                </div>
                            </div>

                            <div class="table-responsive">
                                <table class="table table-hover">
                                    <thead>
                                        <tr>
                                            <th>Date</th>
                                            <th>Description</th>
                                            <th>Amount</th>
                                            <th>Category</th>
                                            <th>Account</th>
                                            <th>Account Balance</th>
                                            <th>Overall Balance</th>
                                            <th>Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody id="transactions-table-body">
                                        <tr>
                                            <td colspan="7" class="text-center">Loading transactions...</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <div class="d-flex justify-content-between align-items-center mt-3">
                                    <div>
                                        <span id="transaction-count-display">Showing 0 of 0 transactions</span>
                                    </div>
                                    <div>
                                        <button id="prev-page-btn" class="btn btn-sm btn-outline-primary me-2" disabled>Previous</button>
                                        <button id="next-page-btn" class="btn btn-sm btn-outline-primary" disabled>Next</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // Global validation function
        function validateAmountFilters() {
            const amountFilterType = document.getElementById('amount-filter-type')?.value;
            const amountFilterValue = document.getElementById('amount-filter-value');
            const amountFilterValue2 = document.getElementById('amount-filter-value-2');
            const amountFilterSecondValue = document.querySelector('.amount-filter-second-value');

            // If no filter type is selected, return true
            if (!amountFilterType) return true;

            // Reset validation state
            if (amountFilterValue) amountFilterValue.classList.remove('is-invalid');
            if (amountFilterValue2) amountFilterValue2.classList.remove('is-invalid');
            
            // Remove any existing error messages
            const existingError = document.querySelector('.amount-filter-error');
            if (existingError) existingError.remove();

            // Validate first amount value
            const value1 = parseFloat(amountFilterValue?.value);
            if (isNaN(value1) || value1 < 0) {
                if (amountFilterValue) amountFilterValue.classList.add('is-invalid');
                showAmountFilterError('Please enter a valid amount');
                return false;
            }

            // Validate second amount value for "between" filter
            if (amountFilterType === 'between') {
                const value2 = parseFloat(amountFilterValue2?.value);
                if (isNaN(value2) || value2 < 0) {
                    if (amountFilterValue2) amountFilterValue2.classList.add('is-invalid');
                    showAmountFilterError('Please enter a valid second amount');
                    return false;
                }

                // Ensure second value is greater than first value
                if (value2 <= value1) {
                    if (amountFilterValue2) amountFilterValue2.classList.add('is-invalid');
                    showAmountFilterError('Second amount must be greater than first amount');
                    return false;
                }
            }

            return true;
        }

        function showAmountFilterError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'amount-filter-error text-danger mt-2';
            errorDiv.textContent = message;
            const secondValueContainer = document.querySelector('.amount-filter-second-value');
            if (secondValueContainer) {
                secondValueContainer.insertAdjacentElement('afterend', errorDiv);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Set up status display
            const statusMessage = document.getElementById('status-message');
            if (statusMessage) {
                statusMessage.innerHTML = '<div class="alert alert-info">Loading your financial data...</div>';
            }
            
            // Load filter options
            loadFilterOptions();
            
            // Fetch data and populate the dashboard - ensure categories is loaded first
            Promise.all([
                fetchCategories(),  // Get categories first for color consistency
                fetchBalanceChart(),
                fetchBalanceData(), // Add milestone chart initialization
                fetchTransactions(),
                fetchMonthlyTrends(),
                fetchPeltAnalysis()
            ])
            .then(() => {
                if (statusMessage) {
                    statusMessage.innerHTML = '<div class="alert alert-success">Data loaded successfully!</div>';
                    // Hide status message after 3 seconds
                    setTimeout(() => {
                        statusMessage.innerHTML = '';
                    }, 3000);
                }
            })
            .catch(error => {
                if (statusMessage) {
                    statusMessage.innerHTML = `<div class="alert alert-danger">Error loading data: ${error.message}</div>`;
                }
            });
            
            // Event listeners for filters
            const applyDateFilter = document.getElementById('apply-date-filter');
            if (applyDateFilter) applyDateFilter.addEventListener('click', fetchTransactions);
            const descriptionSearch = document.getElementById('description-search');
            if (descriptionSearch) descriptionSearch.addEventListener('input', debounce(fetchTransactions, 300));
            const accountTypeFilter = document.getElementById('account-type-filter');
            if (accountTypeFilter) accountTypeFilter.addEventListener('change', fetchTransactions);
            const categoryFilter = document.getElementById('category-filter');
            if (categoryFilter) categoryFilter.addEventListener('change', fetchTransactions);
            const showRecent = document.getElementById('show-recent');
            if (showRecent) showRecent.addEventListener('change', fetchTransactions);
            const showAll = document.getElementById('show-all');
            if (showAll) showAll.addEventListener('change', fetchTransactions);
            const resetFiltersBtn = document.getElementById('reset-filters');
            if (resetFiltersBtn) resetFiltersBtn.addEventListener('click', resetFilters);

            // Amount filter event listeners
            const amountFilterType = document.getElementById('amount-filter-type');
            const amountFilterValue = document.getElementById('amount-filter-value');
            const amountFilterValue2 = document.getElementById('amount-filter-value-2');
            const amountFilterSecondValue = document.querySelector('.amount-filter-second-value');

            if (amountFilterType) {
                amountFilterType.addEventListener('change', function() {
                    // Show/hide second value input for "between" filter
                    if (this.value === 'between') {
                        amountFilterSecondValue.style.display = 'block';
                    } else {
                        amountFilterSecondValue.style.display = 'none';
                        amountFilterValue2.value = ''; // Clear second value when not needed
                    }
                    validateAmountFilters();
                    fetchTransactions();
                });
            }

            if (amountFilterValue) {
                amountFilterValue.addEventListener('input', function() {
                    validateAmountFilters();
                    debounce(fetchTransactions, 300)();
                });
            }

            if (amountFilterValue2) {
                amountFilterValue2.addEventListener('input', function() {
                    validateAmountFilters();
                    debounce(fetchTransactions, 300)();
                });
            }

            // Event listener for cache clearing
            const clearCacheBtn = document.getElementById('clear-cache-btn');
            if (clearCacheBtn) clearCacheBtn.addEventListener('click', function() {
                clearPDFCache();
            });
            
            // Navigation tabs
            const navLinks = document.querySelectorAll('.nav-link');
            navLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    // Remove active class from all links
                    navLinks.forEach(l => l.classList.remove('active'));
                    // Add active class to clicked link
                    this.classList.add('active');
                    // Show the corresponding section
                    const targetId = this.getAttribute('href').substring(1);
                    document.querySelectorAll('section').forEach(section => {
                        section.style.display = 'none';
                    });
                    const targetSection = document.getElementById(targetId);
                    if (targetSection) targetSection.style.display = 'block';
                });
            });
            
            // Initialize pagination
            if (typeof initPagination === 'function') initPagination();

            // Category Management Functions
            if (typeof loadCategoryTable === 'function') loadCategoryTable();

            // Event Listeners for Category Management
            const saveCategoryBtn = document.getElementById('saveCategoryBtn');
            if (saveCategoryBtn) saveCategoryBtn.addEventListener('click', async () => {
                const name = document.getElementById('categoryName')?.value.trim();
                const patterns = document.getElementById('categoryPatterns')?.value
                    .split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0);
                
                if (!name) {
                    alert('Category name is required');
                    return;
                }
                
                try {
                    const response = await fetch('/api/categories', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            name: name,
                            patterns: patterns.map(p => ({
                                terms: p.split(' '),
                                dateAdded: new Date().toISOString(),
                                lastUpdated: new Date().toISOString(),
                                matchCount: 0
                            }))
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to add category');
                    }
                    
                    const modal = bootstrap.Modal.getInstance(document.getElementById('addCategoryModal'));
                    if (modal) modal.hide();
                    document.getElementById('categoryName').value = '';
                    document.getElementById('categoryPatterns').value = '';
                    await Promise.all([
                        loadCategoryTable(),
                        fetchCategories()
                    ]);
                } catch (error) {
                    console.error('Error saving category:', error);
                    alert('Error saving category');
                }
            });

            const updateCategoryBtn = document.getElementById('updateCategoryBtn');
            if (updateCategoryBtn) updateCategoryBtn.addEventListener('click', async () => {
                const id = document.getElementById('editCategoryId')?.value;
                const name = document.getElementById('editCategoryName')?.value.trim();
                const patterns = document.getElementById('editCategoryPatterns')?.value
                    .split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0);
                
                if (!name) {
                    alert('Category name is required');
                    return;
                }
                
                try {
                    const response = await fetch(`/api/categories/${encodeURIComponent(id)}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            name: name,
                            patterns: patterns.map(p => ({
                                terms: p.split(' '),
                                dateAdded: new Date().toISOString(),
                                lastUpdated: new Date().toISOString(),
                                matchCount: 0
                            }))
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to update category');
                    }
                    
                    const modal = bootstrap.Modal.getInstance(document.getElementById('editCategoryModal'));
                    if (modal) modal.hide();
                    await Promise.all([
                        loadCategoryTable(),
                        fetchCategories()
                    ]);
                } catch (error) {
                    console.error('Error updating category:', error);
                    alert('Error updating category');
                }
            });

            const deleteCategoryBtn = document.getElementById('deleteCategoryBtn');
            if (deleteCategoryBtn) deleteCategoryBtn.addEventListener('click', async () => {
                const id = document.getElementById('editCategoryId')?.value;
                if (!confirm(`Are you sure you want to delete the category "${id}"?`)) {
                    return;
                }
                
                try {
                    const response = await fetch(`/api/categories/${encodeURIComponent(id)}`, {
                        method: 'DELETE'
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to delete category');
                    }
                    
                    const modal = bootstrap.Modal.getInstance(document.getElementById('editCategoryModal'));
                    if (modal) modal.hide();
                    await Promise.all([
                        loadCategoryTable(),
                        fetchCategories()
                    ]);
                } catch (error) {
                    console.error('Error deleting category:', error);
                    alert('Error deleting category');
                }
            });

            // Load categories into quick keyword select
            if (typeof loadQuickCategorySelect === 'function') loadQuickCategorySelect();

            // Handle quick keyword form submission
            const quickKeywordForm = document.getElementById('quickKeywordForm');
            if (quickKeywordForm) quickKeywordForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const category = document.getElementById('quickCategorySelect')?.value;
                const keyword = document.getElementById('quickKeyword')?.value.trim();
                
                if (!category || !keyword) {
                    alert('Please select a category and enter a keyword');
                    return;
                }
                
                try {
                    const response = await fetch(`/api/categories/${encodeURIComponent(category)}`);
                    if (!response.ok) {
                        throw new Error('Failed to fetch category details');
                    }
                    
                    const data = await response.json();
                    const patterns = data.patterns || [];
                    
                    // Add new pattern
                    patterns.push({
                        terms: keyword.split(' '),
                        dateAdded: new Date().toISOString(),
                        lastUpdated: new Date().toISOString(),
                        matchCount: 0
                    });
                    
                    // Update category
                    const updateResponse = await fetch(`/api/categories/${encodeURIComponent(category)}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            name: category,
                            patterns: patterns
                        })
                    });
                    
                    if (!updateResponse.ok) {
                        throw new Error('Failed to update category');
                    }
                    
                    // Clear form and show success message
                    document.getElementById('quickKeyword').value = '';
                    alert('Keyword added successfully!');
                    
                    // Refresh categories
                    await Promise.all([
                        loadCategoryTable(),
                        fetchCategories()
                    ]);
                } catch (error) {
                    console.error('Error adding keyword:', error);
                    alert('Error adding keyword');
                }
            });

            // Load quick category select on page load
            if (typeof loadQuickCategorySelect === 'function') loadQuickCategorySelect();
        });
        
        // Debounce function for search input
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Load filter options
        function loadFilterOptions() {
            fetch('/api/filter-options')
                .then(response => response.json())
                .then(data => {
                    const accountTypeSelect = document.getElementById('account-type-filter');
                    const categorySelect = document.getElementById('category-filter');
                    
                    // Populate account types
                    data.account_types.forEach(type => {
                        const option = document.createElement('option');
                        option.value = type;
                        option.textContent = type;
                        accountTypeSelect.appendChild(option);
                    });
                    
                    // Populate categories
                    data.categories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = category;
                        option.textContent = category;
                        categorySelect.appendChild(option);
                    });
                })
                .catch(error => {
                    console.error('Error loading filter options:', error);
                });
        }
        
        // Reset all filters
        function resetFilters() {
            document.getElementById('start-date').value = '';
            document.getElementById('end-date').value = '';
            document.getElementById('description-search').value = '';
            document.getElementById('account-type-filter').value = '';
            document.getElementById('category-filter').value = '';
            document.getElementById('show-all').checked = true;
            // Reset amount filters
            document.getElementById('amount-filter-type').value = '';
            document.getElementById('amount-filter-value').value = '';
            document.getElementById('amount-filter-value-2').value = '';
            document.querySelector('.amount-filter-second-value').style.display = 'none';
            fetchTransactions();
        }
        
        // Transactions page variables
        let allTransactions = [];
        let currentPage = 1;
        const transactionsPerPage = 20;
        
        async function fetchTransactions() {
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const description = document.getElementById('description-search').value;
            const accountType = document.getElementById('account-type-filter').value;
            const category = document.getElementById('category-filter').value;
            const showRecent = document.getElementById('show-recent').checked;
            
            // Get amount filter values
            const amountFilterType = document.getElementById('amount-filter-type').value;
            const amountFilterValue = parseFloat(document.getElementById('amount-filter-value').value) || 0;
            const amountFilterValue2 = parseFloat(document.getElementById('amount-filter-value-2').value) || 0;
            
            let url = '/api/transactions';
            const params = new URLSearchParams();
            
            if (startDate) params.append('start_date', startDate);
            if (endDate) params.append('end_date', endDate);
            if (description) params.append('description', description);
            if (accountType) params.append('account_type', accountType);
            if (category) params.append('category', category);
            params.append('show_recent', showRecent);
            
            // Add amount filter parameters
            if (amountFilterType) {
                params.append('amount_filter_type', amountFilterType);
                params.append('amount_filter_value', amountFilterValue);
                if (amountFilterType === 'between') {
                    params.append('amount_filter_value_2', amountFilterValue2);
                }
            }
            
            // Append parameters to URL if they exist
            url += '?' + params.toString();
            
            document.getElementById('transactions-table-body').innerHTML = '<tr><td colspan="7" class="text-center">Loading transactions...</td></tr>';
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Failed to fetch transactions');
                }
                const data = await response.json();
                
                if (Array.isArray(data)) {
                    // Apply amount filtering client-side for better UX
                    allTransactions = filterTransactionsByAmount(data, amountFilterType, amountFilterValue, amountFilterValue2);
                    
                    // Reset current page to 1 when filters change
                    currentPage = 1;
                    
                    // Display transactions and update pagination
                    displayTransactions(currentPage);
                    document.getElementById('transaction-count-display').innerText = 
                        `Showing ${Math.min(transactionsPerPage, allTransactions.length)} of ${allTransactions.length} transactions`;
                    updatePaginationButtons();
                } else {
                    throw new Error('Invalid data format received');
                }
            } catch (error) {
                console.error('Error fetching transactions:', error);
                document.getElementById('transactions-table-body').innerHTML = 
                    '<tr><td colspan="7" class="text-center text-danger">Error loading transactions: ' + error.message + '</td></tr>';
            }
        }

        // Helper function to filter transactions by amount
        function filterTransactionsByAmount(transactions, filterType, value1, value2) {
            if (!filterType || !validateAmountFilters()) return transactions;

            return transactions.filter(transaction => {
                const amount = Math.abs(parseFloat(transaction.Amount));
                
                switch (filterType) {
                    case 'greater':
                        return amount > value1;
                    case 'less':
                        return amount < value1;
                    case 'equal':
                        return Math.abs(amount - value1) < 0.01; // Using small epsilon for float comparison
                    case 'between':
                        const min = Math.min(value1, value2);
                        const max = Math.max(value1, value2);
                        return amount >= min && amount <= max;
                    default:
                        return true;
                }
            });
        }
            
        function displayTransactions(page) {
            const startIndex = (page - 1) * transactionsPerPage;
            const endIndex = startIndex + transactionsPerPage;
            const pageTransactions = allTransactions.slice(startIndex, endIndex);
            
            const tableBody = document.getElementById('transactions-table-body');
            if (!tableBody) return;
            tableBody.innerHTML = '';
            
            if (pageTransactions.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="7" class="text-center">No transactions found in this date range.</td></tr>';
                return;
            }
            
            // Define aesthetic colors for different account types
            const accountTypeColors = {
                'Chequing': 'bg-success bg-opacity-75 text-white',  // Green
                'Savings': 'bg-info bg-opacity-75 text-white',      // Blue
                'Credit': 'bg-dark bg-opacity-75 text-white'        // Aesthetic black
            };
            
            pageTransactions.forEach(transaction => {
                const row = document.createElement('tr');
                
                // Format date
                const date = new Date(transaction.DateTime);
                const formattedDate = date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                
                // Format amount with sign and color
                const amount = parseFloat(transaction.Amount);
                const formattedAmount = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(amount);
                
                // Get account type style
                const accountTypeClass = accountTypeColors[transaction['Account Type']] || 'bg-secondary';
                
                // Get category color from the global categoryColors object
                const categoryColor = window.categoryColors && window.categoryColors[transaction.Classification]
                    ? window.categoryColors[transaction.Classification]
                    : '#6c757d'; // Default grey if no color found
                
                // Create a unique identifier for the transaction using DateTime and Amount
                const transactionDate = new Date(transaction.DateTime);
                const transactionDateStr = transactionDate.toISOString().split('T')[0]; // Get YYYY-MM-DD format
                const transactionId = `${transactionDateStr}_${transaction.Amount}`;
                
                row.innerHTML = `
                    <td>${formattedDate}</td>
                    <td>${transaction.Details || ''}</td>
                    <td class="${amount < 0 ? 'text-danger' : 'text-success'}">${formattedAmount}</td>
                    <td>
                        <div class="d-flex align-items-center">
                            <span class="badge me-2" style="background-color: ${categoryColor}">${transaction.Classification || 'Uncategorized'}</span>
                            <div class="dropdown">
                                <button class="btn btn-link btn-sm p-0 text-muted" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
                                        <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
                                    </svg>
                                </button>
                                <ul class="dropdown-menu dropdown-menu-end" data-transaction-id="${transactionId}">
                                    <li><h6 class="dropdown-header">Change Category</h6></li>
                                    ${Object.keys(window.categoryColors || {}).map(category => `
                                        <li>
                                            <a class="dropdown-item" href="#" data-category="${category}">
                                                <span class="badge me-2" style="background-color: ${window.categoryColors[category]}">${category}</span>
                                            </a>
                                        </li>
                                    `).join('')}
                                    <li><hr class="dropdown-divider"></li>
                                    <li>
                                        <a class="dropdown-item text-danger" href="#" data-action="reset">
                                            <i class="bi bi-x-circle me-2"></i>Reset to Default
                                        </a>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </td>
                    <td><span class="badge ${accountTypeClass}">${transaction['Account Type'] || ''}</span></td>
                    <td>${transaction.account_balance !== null ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(transaction.account_balance) : '-'}</td>
                    <td>${transaction.running_balance !== null ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(transaction.running_balance) : '-'}</td>
                `;
                
                // Add event listeners for category selection
                const dropdown = row.querySelector('.dropdown-menu');
                dropdown.addEventListener('click', async function(e) {
                    e.preventDefault();
                    const target = e.target.closest('.dropdown-item');
                    if (!target) return;
                    
                    const transactionId = this.dataset.transactionId;
                    const action = target.dataset.action;
                    
                    try {
                        if (action === 'reset') {
                            const response = await fetch('/api/transactions/manual-category', {
                                method: 'DELETE',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    transaction_id: transactionId
                                })
                            });
                            
                            if (!response.ok) {
                                throw new Error('Failed to reset category');
                            }
                        } else {
                            const category = target.dataset.category;
                            const response = await fetch('/api/transactions/manual-category', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    transaction_id: transactionId,
                                    category: category
                                })
                            });
                            
                            if (!response.ok) {
                                throw new Error('Failed to update category');
                            }
                        }
                        
                        // Refresh the transactions to show the new category
                        await fetchTransactions();
                        
                        // Refresh the categories display
                        await fetchCategories();
                        
                    } catch (error) {
                        console.error('Error updating category:', error);
                        alert('Error updating category: ' + error.message);
                    }
                });
                
                tableBody.appendChild(row);
            });
        }
            
        function initPagination() {
            document.getElementById('prev-page-btn').addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    displayTransactions(currentPage);
                    updatePaginationButtons();
                }
            });
            
            document.getElementById('next-page-btn').addEventListener('click', () => {
                const maxPages = Math.ceil(allTransactions.length / transactionsPerPage);
                if (currentPage < maxPages) {
                    currentPage++;
                    displayTransactions(currentPage);
                    updatePaginationButtons();
                }
            });
        }
            
        function updatePaginationButtons() {
            const prevBtn = document.getElementById('prev-page-btn');
            const nextBtn = document.getElementById('next-page-btn');
            const maxPages = Math.ceil(allTransactions.length / transactionsPerPage);
            
            prevBtn.disabled = currentPage === 1;
            nextBtn.disabled = currentPage === maxPages || maxPages === 0;
        }
        
        function clearPDFCache() {
            if (!confirm('Are you sure you want to clear the PDF cache? You will need to reprocess all PDFs next time.')) {
                return;
            }
            
            fetch('/api/clear_cache', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('PDF cache cleared successfully');
                        // Force a hard reload of the page to ensure fresh data
                        window.location.href = window.location.href;
                    } else {
                        alert('Error: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('Error clearing cache:', error);
                    alert('Error clearing cache. See console for details.');
                });
        }
        
        async function fetchBalanceChart() {
            try {
                const response = await fetch('/api/balance-chart');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                renderBalanceChart(data);
                return data;
            } catch (error) {
                console.error('Error fetching balance chart data:', error);
                throw error;
            }
        }
        
        async function fetchPeltAnalysis() {
            try {
                const response = await fetch('/api/pelt-analysis');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                renderPeltChart(data);
                renderRateOfChangeChart(data.rateOfChange);
                return data;
            } catch (error) {
                console.error('Error fetching PELT analysis data:', error);
                throw error;
            }
        }
        
        function renderBalanceChart(data) {
            const ctx = document.getElementById('balanceChart').getContext('2d');
            
            // Clean up any existing chart
            const existingChart = Chart.getChart(ctx.canvas);
            if (existingChart) {
                existingChart.destroy();
            }

            // Gradient fill for the area below the line
            const gradient = ctx.createLinearGradient(0, 0, 0, 400);
            gradient.addColorStop(0, 'rgba(187, 37, 37, 0.3)');  // Semi-transparent red at top
            gradient.addColorStop(1, 'rgba(187, 37, 37, 0.01)'); // Almost transparent at bottom
            
            // Enhance the dataset with better styling
            if (data.datasets && data.datasets.length > 0) {
                data.datasets[0].borderColor = 'rgba(187, 37, 37, 0.8)';
                data.datasets[0].backgroundColor = gradient;
                data.datasets[0].borderWidth = 2;
                data.datasets[0].pointRadius = 0;
                data.datasets[0].pointHoverRadius = 6;
                data.datasets[0].pointHoverBackgroundColor = 'rgba(187, 37, 37, 1)';
                data.datasets[0].pointHoverBorderColor = 'white';
                data.datasets[0].pointHoverBorderWidth = 2;
                data.datasets[0].tension = 0.3; // Add slight curve to the line
                data.datasets[0].fill = true;
            }
            
            // Create chart with improved options
            const chart = new Chart(ctx, {
                type: 'line',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 1500, // Smoother animation
                        easing: 'easeOutQuart',
                        onComplete: function() {
                            // Hide loader when animation is complete
                            document.getElementById('balanceChartLoader').classList.add('hidden');
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    scales: {
                        x: {
                            type: 'category',
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxTicksLimit: 8,
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 11
                                }
                            }
                        },
                        y: {
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.05)',
                                drawBorder: false
                            },
                            ticks: {
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 11
                                },
                                callback: function(value) {
                                    return new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD',
                                        maximumFractionDigits: 0
                                    }).format(value);
                                }
                            },
                            title: {
                                display: true,
                                text: 'Balance',
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 12,
                                    weight: '500'
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.7)',
                            titleFont: {
                                family: 'Inter',
                                size: 12
                            },
                            bodyFont: {
                                family: 'Inter',
                                size: 12
                            },
                            callbacks: {
                                label: function(context) {
                                    return 'Balance: ' + new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD'
                                    }).format(context.raw);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        async function fetchCategories() {
            try {
                const response = await fetch('/api/categories');
                if (!response.ok) {
                    throw new Error('Failed to fetch categories');
                }
                
                const categories = await response.json();
                
                if (categories.error) {
                    throw new Error(categories.error);
                }
                
                // Render the categories list
                renderCategories(categories.counts || {}, categories.colors || {});
                
                // Render both spending and income charts
                renderCategoryChart('categoryChart', categories.spending || {}, categories.colors || {}, 'Spending');
                renderCategoryChart('incomeChart', categories.income || {}, categories.colors || {}, 'Income');
                
                // Show messages if there's no data
                if (categories.has_spending_data === false) {
                    console.warn("No spending data available - check that you have transactions with negative amounts");
                    const chartContainer = document.querySelector('#categoryChart').parentNode;
                    const warningEl = document.createElement('div');
                    warningEl.className = 'small text-warning text-center mt-2';
                    warningEl.textContent = 'Note: No expense transactions found to display in chart';
                    chartContainer.appendChild(warningEl);
                }
                
                if (categories.has_income_data === false) {
                    console.warn("No income data available - check that you have transactions with positive amounts");
                    const chartContainer = document.querySelector('#incomeChart').parentNode;
                    const warningEl = document.createElement('div');
                    warningEl.className = 'small text-warning text-center mt-2';
                    warningEl.textContent = 'Note: No income transactions found to display in chart';
                    chartContainer.appendChild(warningEl);
                }
                
                // Store colors globally for other charts to use
                window.categoryColors = categories.colors || {};
                
                return true;
            } catch (error) {
                console.error('Error fetching categories:', error);
                document.getElementById('categories-container').innerHTML = 
                    '<div class="alert alert-danger w-100">Failed to load categories: ' + error.message + '</div>';
                renderCategoryChart('categoryChart', null); // Ensure spending chart shows the "no data" state
                renderCategoryChart('incomeChart', null); // Ensure income chart shows the "no data" state
                return false;
            }
        }
        
        function renderCategories(categories, categoryColors) {
            const container = document.getElementById('categories-container');
            if (!container) {
                console.error('Categories container not found');
                return;
            }
            
            if (Object.keys(categories).length === 0) {
                container.innerHTML = '<p class="text-center w-100">No categories found</p>';
                return;
            }
            
            let html = '';
            for (const category in categories) {
                const bgColor = categoryColors && categoryColors[category] ? categoryColors[category] : '#607D8B';
                const count = categories[category];
                html += `
                    <div class="category-badge" style="background-color: ${bgColor}; color: white; padding: 5px 10px; border-radius: 15px; margin: 3px; font-size: 0.9rem;">
                        ${category}: ${count}
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        function renderCategoryChart(canvasId, categoryData, categoryColors, chartType) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            // If we already have a chart, destroy it to prevent duplicates
            const existingChart = Chart.getChart(ctx.canvas);
            if (existingChart) {
                existingChart.destroy();
            }
            
            // If no real data yet, show placeholder
            if (!categoryData || Object.keys(categoryData).length === 0) {
                new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: [`No ${chartType.toLowerCase()} data available`],
                        datasets: [{
                            data: [1],
                            backgroundColor: ['#f0f0f0'],
                            borderColor: '#e0e0e0',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        cutout: '70%',
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: {
                                    font: {
                                        family: 'Inter',
                                        size: 12
                                    },
                                    padding: 15,
                                    color: '#666'
                                }
                            },
                            tooltip: {
                                enabled: false
                            }
                        },
                        animation: {
                            animateScale: true,
                            animateRotate: true,
                            duration: 1000,
                            easing: 'easeOutQuart',
                            onComplete: function() {
                                // Hide loader even for placeholder
                                document.getElementById(`${canvasId}Loader`).classList.add('hidden');
                            }
                        }
                    }
                });
                return;
            }
            
            // Sort categories by amount (descending)
            const sortedEntries = Object.entries(categoryData)
                .sort((a, b) => b[1] - a[1]);
            
            const labels = sortedEntries.map(entry => entry[0]);
            const data = sortedEntries.map(entry => entry[1]);
            
            // Calculate total for percentages
            const total = data.reduce((sum, value) => sum + value, 0);
            
            // Use provided category colors or fallback to defaults
            const colors = labels.map(label => 
                categoryColors && categoryColors[label] ? categoryColors[label] : '#607D8B'
            );
            
            // Add slight transparency to colors for better aesthetic
            const backgroundColors = colors.map(color => {
                // If color is hex, convert to rgba
                if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r},${g},${b},0.85)`;
                }
                // If already rgba, just return
                return color;
            });
            
            // Slightly darker colors for hover state
            const hoverColors = backgroundColors.map(color => {
                if (color.startsWith('rgba')) {
                    return color.replace('0.85', '1');
                }
                return color;
            });
            
            new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors,
                        hoverBackgroundColor: hoverColors,
                        borderColor: 'white',
                        borderWidth: 2,
                        hoverBorderWidth: 0,
                        hoverOffset: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '60%',
                    layout: {
                        padding: 15
                    },
                    animation: {
                        animateScale: true,
                        animateRotate: true,
                        duration: 1000,
                        easing: 'easeOutQuart',
                        onComplete: function() {
                            // Hide loader
                            document.getElementById(`${canvasId}Loader`).classList.add('hidden');
                            
                            // Add total text in the center
                            const chartArea = document.querySelector(`#${canvasId}`).parentNode;
                            let centerText = chartArea.querySelector('.doughnut-center-text');
                            
                            if (!centerText) {
                                centerText = document.createElement('div');
                                centerText.className = 'doughnut-center-text';
                                centerText.style.position = 'absolute';
                                centerText.style.top = '50%';
                                centerText.style.left = '50%';
                                centerText.style.transform = 'translate(-50%, -50%)';
                                centerText.style.textAlign = 'center';
                                centerText.style.pointerEvents = 'none';
                                centerText.style.fontFamily = 'Inter, sans-serif';
                                
                                chartArea.style.position = 'relative';
                                chartArea.appendChild(centerText);
                            }
                            
                            const formattedTotal = new Intl.NumberFormat('en-US', {
                                style: 'currency',
                                currency: 'USD',
                                maximumFractionDigits: 0
                            }).format(total);
                            
                            centerText.innerHTML = `
                                <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Total ${chartType}</div>
                                <div style="font-size: 18px; font-weight: 600; color: #333;">${formattedTotal}</div>
                            `;
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                font: {
                                    family: 'Inter',
                                    size: 12
                                },
                                padding: 15,
                                usePointStyle: true,
                                pointStyle: 'circle',
                                color: '#666',
                                // Limit the number of legend items shown if there are too many
                                filter: function(legendItem, data) {
                                    // Only show top categories that make up 95% of total plus "Other"
                                    const index = legendItem.index;
                                    const value = data.datasets[0].data[index];
                                    const percentage = (value / total) * 100;
                                    
                                    // Always show top 6 categories regardless of percentage
                                    if (index < 6) return true;
                                    
                                    // Show categories with at least 1% of total
                                    return percentage >= 1;
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.7)',
                            titleFont: {
                                family: 'Inter',
                                size: 13,
                                weight: 'bold'
                            },
                            bodyFont: {
                                family: 'Inter',
                                size: 12
                            },
                            padding: 12,
                            cornerRadius: 6,
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.raw || 0;
                                    const percentage = Math.round((value / total) * 100);
                                    return `${label}: ${new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD'
                                    }).format(value)} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderTrendsChart(data = null) {
            const ctx = document.getElementById('trendsChart').getContext('2d');
            
            // If we already have a chart, destroy it to prevent duplicates
            const existingChart = Chart.getChart(ctx.canvas);
            if (existingChart) {
                existingChart.destroy();
            }
            
            // If no real data yet, show placeholder
            if (!data) {
                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Loading...'],
                        datasets: [{
                            label: 'Monthly Net Transactions',
                            data: [0],
                            backgroundColor: '#cccccc'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
                return;
            }
            
            // Apply consistent colors to datasets if available
            if (window.categoryColors) {
                data.datasets.forEach(dataset => {
                    if (window.categoryColors[dataset.label]) {
                        dataset.backgroundColor = window.categoryColors[dataset.label];
                    }
                });
            }
            
            // Create chart with improved options
            new Chart(ctx, {
                type: 'bar',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.raw || 0;
                                    const sign = value >= 0 ? '+' : '';
                                    return `${label}: ${sign}${new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD'
                                    }).format(value)}`;
                                }
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                // Limit the number of legends displayed
                                filter: function(legendItem, data) {
                                    // Only show categories with significant transactions
                                    const dataset = data.datasets[legendItem.datasetIndex];
                                    const total = dataset.data.reduce((a, b) => Math.abs(a) + Math.abs(b), 0);
                                    return total > 100; // Only show categories with more than $100 total
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                autoSkip: true,
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: false, // Allow negative values
                            title: {
                                display: true,
                                text: 'Net Amount ($)'
                            },
                            grid: {
                                color: function(context) {
                                    if (context.tick.value === 0) {
                                        return 'rgba(0, 0, 0, 0.5)';
                                    }
                                    return 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    if (context.tick.value === 0) {
                                        return 2;
                                    }
                                    return 1;
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD',
                                        maximumFractionDigits: 0
                                    }).format(value);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        async function fetchMonthlyTrends() {
            try {
                const response = await fetch('/api/monthly-trends');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                renderTrendsChart(data);
                return data;
            } catch (error) {
                console.error('Error fetching monthly trends data:', error);
                throw error;
            }
        }
        
        function renderPeltChart(data) {
            const ctx = document.getElementById('peltChart').getContext('2d');
            
            // Clean up any existing chart
            const existingChart = Chart.getChart(ctx.canvas);
            if (existingChart) {
                existingChart.destroy();
            }
            
            // If no data or error, show placeholder
            if (!data || data.error || !data.datasets || data.datasets.length === 0) {
                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: ['No data available'],
                        datasets: [{
                            data: [0],
                            borderColor: '#ccc',
                            borderDash: [5, 5]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        }
                    }
                });
                return;
            }
            
            // Create the chart with improved options
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: data.datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    elements: {
                        line: {
                            tension: 0.3 // Add slight curve to lines
                        }
                    },
                    scales: {
                        x: {
                            type: 'category',
                            grid: {
                                color: 'rgba(0,0,0,0.05)',
                                display: true
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 12
                                }
                            },
                            ticks: {
                                maxTicksLimit: 8,
                                autoSkip: true,
                                maxRotation: 45,
                                minRotation: 45,
                                color: '#666',
                                font: {
                                    family: 'Inter'
                                }
                            }
                        },
                        y: {
                            grid: {
                                color: 'rgba(0,0,0,0.05)',
                                display: true
                            },
                            title: {
                                display: true,
                                text: 'Balance',
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 12
                                }
                            },
                            ticks: {
                                color: '#666',
                                font: {
                                    family: 'Inter'
                                },
                                callback: function(value) {
                                    return new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD',
                                        maximumFractionDigits: 0
                                    }).format(value);
                                }
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            titleFont: {
                                family: 'Inter'
                            },
                            bodyFont: {
                                family: 'Inter'
                            },
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    return `${context.dataset.label}: ${new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD'
                                    }).format(value)}`;
                                }
                            },
                            displayColors: true,
                            backgroundColor: 'rgba(0,0,0,0.7)'
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                font: {
                                    family: 'Inter'
                                },
                                color: '#666',
                                usePointStyle: true,
                                pointStyle: 'circle'
                            }
                        }
                    }
                }
            });
            
            // Add vertical lines for change points
            if (data.changePoints && data.changePoints.length > 0) {
                const chartContainer = chart.canvas.parentNode;
                chartContainer.style.position = 'relative';
                
                // Remove any existing change point lines
                const existingLines = chartContainer.querySelectorAll('.change-point-line');
                existingLines.forEach(line => line.remove());
                
                // Add change point lines after a slight delay to ensure chart is rendered
                setTimeout(() => {
                    data.changePoints.forEach((date, index) => {
                        const dateIndex = data.labels.indexOf(date);
                        if (dateIndex === -1) return;
                        
                        const meta = chart.getDatasetMeta(0);
                        if (!meta.data[dateIndex]) return;
                        
                        const x = meta.data[dateIndex].x;
                        
                        // Create the line element
                        const line = document.createElement('div');
                        line.className = 'change-point-line';
                        line.style.position = 'absolute';
                        line.style.top = '0';
                        line.style.bottom = '0';
                        line.style.width = '1px';
                        line.style.backgroundColor = 'rgba(0, 0, 0, 0.15)';
                        line.style.left = `${x}px`;
                        line.style.pointerEvents = 'none';
                        line.style.zIndex = '10';
                        line.style.boxShadow = '0 0 2px rgba(0, 0, 0, 0.1)';
                        
                        // Add a subtle point at the top of the line
                        const point = document.createElement('div');
                        point.style.position = 'absolute';
                        point.style.top = '0';
                        point.style.left = '-2px';
                        point.style.width = '5px';
                        point.style.height = '5px';
                        point.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
                        point.style.borderRadius = '50%';
                        
                        line.appendChild(point);
                        chartContainer.appendChild(line);
                        
                        // Add date tooltip
                        line.title = `Change point: ${date}`;
                    });
                }, 200);
            }
        }
        
        function renderRateOfChangeChart(rateData) {
            const ctx = document.getElementById('rateOfChangeChart').getContext('2d');
            
            // Clean up any existing chart
            const existingChart = Chart.getChart(ctx.canvas);
            if (existingChart) {
                existingChart.destroy();
            }
            
            // If no data, show placeholder
            if (!rateData || !rateData.data || rateData.data.length === 0) {
                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: ['No data available'],
                        datasets: [{
                            data: [0],
                            borderColor: '#ccc',
                            borderDash: [5, 5]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        }
                    }
                });
                return;
            }
            
            // Create datasets for positive and negative values
            const positiveData = rateData.data.map(val => val > 0 ? val : null);
            const negativeData = rateData.data.map(val => val < 0 ? val : null);
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: rateData.labels,
                    datasets: [
                        {
                            label: 'Positive Rate of Change',
                            data: positiveData,
                            borderColor: 'rgba(40, 167, 69, 0.8)',
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: true
                        },
                        {
                            label: 'Negative Rate of Change',
                            data: negativeData,
                            borderColor: 'rgba(220, 53, 69, 0.8)',
                            backgroundColor: 'rgba(220, 53, 69, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'category',
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxTicksLimit: 8,
                                autoSkip: true,
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Weekly Rate of Change ($)'
                            },
                            grid: {
                                color: function(context) {
                                    if (context.tick.value === 0) {
                                        return 'rgba(0, 0, 0, 0.5)';
                                    }
                                    return 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    if (context.tick.value === 0) {
                                        return 2;
                                    }
                                    return 1;
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD',
                                        maximumFractionDigits: 0
                                    }).format(value);
                                }
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    if (value === null) return null;
                                    
                                    const sign = value >= 0 ? '+' : '';
                                    return `Rate of Change: ${sign}${new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD'
                                    }).format(value)}/week`;
                                }
                            }
                        },
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }

        // Initialize milestone chart
        let milestoneChart = null;
        const milestones = [10000, 50000, 100000, 250000, 500000, 1000000];

        function renderMilestoneChart(balanceData) {
            const ctx = document.getElementById('milestoneChart').getContext('2d');
            
            // Get the current balance from the data
            const currentBalance = balanceData && balanceData.datasets && balanceData.datasets[0] && balanceData.datasets[0].data 
                ? balanceData.datasets[0].data[balanceData.datasets[0].data.length - 1] 
                : 0;
            
            // Calculate next milestone
            const nextMilestone = milestones.find(m => m > currentBalance) || milestones[milestones.length - 1];
            const previousMilestone = milestones.filter(m => m <= currentBalance).pop() || 0;
            
            // Calculate progress percentage between current milestones
            const progress = ((currentBalance - previousMilestone) / (nextMilestone - previousMilestone)) * 100;
            
            // Fetch PELT analysis data for trend calculation
            fetch('/api/pelt-analysis')
                .then(response => response.json())
                .then(peltData => {
                    // Get the most recent rate of change
                    let trend = 0;
                    if (peltData && peltData.rateOfChange && peltData.rateOfChange.data) {
                        const rateData = peltData.rateOfChange.data;
                        // Get the last non-null value from the rate of change data
                        for (let i = rateData.length - 1; i >= 0; i--) {
                            if (rateData[i] !== null) {
                                trend = rateData[i];
                                break;
                            }
                        }
                    }

                    // Calculate weeks to next milestone using weekly rate of change
                    const remainingAmount = nextMilestone - currentBalance;
                    const weeksToMilestone = trend > 0 ? Math.ceil(remainingAmount / trend) : Infinity;
                    
                    // Convert weeks to months and years for display
                    const totalMonths = Math.ceil(weeksToMilestone / 4.33); // Average weeks per month
                    const years = Math.floor(totalMonths / 12);
                    const months = totalMonths % 12;

                    // Format the time estimate text
                    const getTimeEstimateText = () => {
                        if (trend <= 0) {
                            return 'Trend is negative';
                        }
                        if (totalMonths > 36) {
                            return 'Over 3 years';
                        }
                        if (years === 0) {
                            return `${months} month${months !== 1 ? 's' : ''}`;
                        }
                        if (months === 0) {
                            return `${years} year${years !== 1 ? 's' : ''}`;
                        }
                        return `${years} year${years !== 1 ? 's' : ''} ${months} month${months !== 1 ? 's' : ''}`;
                    };

                    // Create the milestone visualization
                    const milestoneInfo = document.createElement('div');
                    milestoneInfo.className = 'milestone-timeline-container';
                    milestoneInfo.innerHTML = `
                        <style>
                            .milestone-timeline-container {
                                padding: 30px 20px;
                                font-family: 'Inter', sans-serif;
                            }
                            .timeline-track {
                                height: 8px;
                                background: #eef2f7;
                                border-radius: 4px;
                                position: relative;
                                margin: 40px 0;
                            }
                            .timeline-progress {
                                position: absolute;
                                left: 0;
                                top: 0;
                                height: 100%;
                                background: linear-gradient(90deg, #4285f4, #5c9fff);
                                border-radius: 4px;
                                transition: width 1s ease-in-out;
                            }
                            .timeline-marker {
                                width: 24px;
                                height: 24px;
                                background: white;
                                border: 3px solid #4285f4;
                                border-radius: 50%;
                                position: absolute;
                                top: 50%;
                                transform: translate(-50%, -50%);
                                transition: left 1s ease-in-out;
                                box-shadow: 0 2px 6px rgba(0,0,0,0.2);
                            }
                            .milestone-marker {
                                position: absolute;
                                top: -30px;
                                transform: translateX(-50%);
                                text-align: center;
                            }
                            .milestone-marker::after {
                                content: '';
                                position: absolute;
                                bottom: -10px;
                                left: 50%;
                                transform: translateX(-50%);
                                width: 2px;
                                height: 8px;
                                background: #cbd5e1;
                            }
                            .milestone-value {
                                font-weight: 600;
                                color: #1a73e8;
                                font-size: 0.9rem;
                            }
                            .current-balance {
                                position: absolute;
                                top: 25px;
                                transform: translateX(-50%);
                                text-align: center;
                                background: white;
                                padding: 8px 16px;
                                border-radius: 20px;
                                box-shadow: 0 2px 12px rgba(0,0,0,0.1);
                                border: 1px solid #e1e8f0;
                            }
                            .current-balance-value {
                                font-weight: 700;
                                color: #1e293b;
                                font-size: 1.1rem;
                            }
                            .milestone-stats {
                                display: grid;
                                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                                gap: 20px;
                                margin-top: 60px;
                            }
                            .stat-card {
                                background: white;
                                padding: 20px;
                                border-radius: 12px;
                                box-shadow: 0 2px 12px rgba(0,0,0,0.08);
                                border: 1px solid #e1e8f0;
                            }
                            .stat-label {
                                color: #64748b;
                                font-size: 0.9rem;
                                margin-bottom: 8px;
                            }
                            .stat-value {
                                color: #1e293b;
                                font-weight: 600;
                                font-size: 1.1rem;
                            }
                            .trend-indicator {
                                display: inline-flex;
                                align-items: center;
                                padding: 4px 12px;
                                border-radius: 16px;
                                font-size: 0.9rem;
                                margin-left: 8px;
                            }
                            .trend-positive {
                                background: #dcfce7;
                                color: #166534;
                            }
                            .trend-negative {
                                background: #fee2e2;
                                color: #991b1b;
                            }
                        </style>
                        <div class="timeline-track">
                            <div class="timeline-progress" style="width: ${progress}%"></div>
                            <div class="timeline-marker" style="left: ${progress}%">
                                <div class="current-balance">
                                    <div class="current-balance-value">
                                        ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(currentBalance)}
                                    </div>
                                    <div style="font-size: 0.8rem; color: #64748b;">Current Balance</div>
                                </div>
                            </div>
                            <div class="milestone-marker" style="left: 0%">
                                <div class="milestone-value">
                                    ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(previousMilestone)}
                                </div>
                            </div>
                            <div class="milestone-marker" style="left: 100%">
                                <div class="milestone-value">
                                    ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(nextMilestone)}
                                </div>
                            </div>
                        </div>
                        <div class="milestone-stats">
                            <div class="stat-card">
                                <div class="stat-label">Progress to Next Milestone</div>
                                <div class="stat-value">${progress.toFixed(1)}%</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Weekly Rate of Change</div>
                                <div class="stat-value">
                                    ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(trend)}
                                    <span class="trend-indicator ${trend >= 0 ? 'trend-positive' : 'trend-negative'}">
                                        ${trend >= 0 ? '' : ''} per week
                                    </span>
                                </div>
                                <div class="small text-muted mt-2">Based on PELT analysis</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Estimated Time to Next Milestone</div>
                                <div class="stat-value">
                                    ${getTimeEstimateText()}
                                </div>
                                <div class="small text-muted mt-2">
                                    ${trend > 0 ? `Need ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(remainingAmount)} more` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // Remove any existing milestone info
                    const existingInfo = document.querySelector('#milestoneChart').parentNode.querySelector('.milestone-timeline-container');
                    if (existingInfo) {
                        existingInfo.remove();
                    }
                    
                    // Remove the canvas since we're not using Chart.js anymore
                    const canvas = document.getElementById('milestoneChart');
                    canvas.remove();
                    
                    // Add the new timeline visualization
                    document.getElementById('milestoneChartLoader').insertAdjacentElement('afterend', milestoneInfo);
                    
                    // Hide the loading spinner
                    document.getElementById('milestoneChartLoader').classList.add('hidden');
                })
                .catch(error => {
                    console.error('Error fetching PELT analysis:', error);
                    // Fallback to simple trend calculation if PELT analysis fails
                    let trend = 0;
                    if (balanceData && balanceData.datasets && balanceData.datasets[0]) {
                        const data = balanceData.datasets[0].data;
                        if (data.length >= 2) {
                            const numMonths = Math.min(3, data.length - 1);
                            const recentChange = data[data.length - 1] - data[data.length - 1 - numMonths];
                            trend = recentChange / numMonths;
                        }
                    }
                    // Continue with the rest of the visualization...
                    // (Same code as above, just with the fallback trend calculation)
                });
        }

        // Add milestone chart initialization to the balance data fetch
        async function fetchBalanceData() {
            try {
                const response = await fetch('/api/balance-chart');
                if (!response.ok) {
                    throw new Error('Failed to fetch balance data');
                }
                const data = await response.json();
                
                if (!data || !data.datasets || !data.datasets[0] || !data.datasets[0].data) {
                    throw new Error('Invalid balance data format');
                }
                
                // Extract the last balance value from the datasets
                const lastDataset = data.datasets[0];
                const lastBalance = lastDataset.data[lastDataset.data.length - 1] || 0;
                
                // Create a simplified data object for the milestone chart
                const milestoneData = {
                    datasets: [{
                        data: [lastBalance],
                        backgroundColor: ['#4CAF50'],
                        borderColor: ['#388E3C'],
                        borderWidth: 1
                    }]
                };
                
                // Render both charts
                renderBalanceChart(data);
                renderMilestoneChart(milestoneData);
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('balanceChart').innerHTML = `<div class="alert alert-danger">Error loading data: ${error.message}</div>`;
                document.getElementById('milestoneChart').innerHTML = `<div class="alert alert-danger">Error loading data: ${error.message}</div>`;
            }
        }

        // Category Management Functions
        async function loadCategoryTable() {
            const container = document.getElementById('categoryTableContainer');
            if (!container) return;
            try {
                const response = await fetch('/api/categories/details');
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                if (!data.categories) {
                    throw new Error('No categories data received');
                }

                // Create table structure
                let tableHtml = `
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Category Name</th>
                                <th>Keywords</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                // Add each category to the table
                for (const [name, details] of Object.entries(data.categories)) {
                    const keywords = details.patterns ? details.patterns.join(', ') : '';
                    tableHtml += `
                        <tr>
                            <td>${name}</td>
                            <td>${keywords}</td>
                            <td>
                                <button class="btn btn-sm btn-primary edit-category" data-category="${name}">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn btn-sm btn-danger delete-category" data-category="${name}">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </td>
                        </tr>
                    `;
                }

                tableHtml += `
                        </tbody>
                    </table>
                `;

                container.innerHTML = tableHtml;

                // Add event listeners for edit and delete buttons
                container.querySelectorAll('.edit-category').forEach(button => {
                    button.addEventListener('click', () => {
                        const category = button.dataset.category;
                        const details = data.categories[category];
                        document.getElementById('editCategoryId').value = category;
                        document.getElementById('editCategoryName').value = category;
                        document.getElementById('editCategoryKeywords').value = details.patterns ? details.patterns.join(', ') : '';
                        $('#editCategoryModal').modal('show');
                    });
                });

                container.querySelectorAll('.delete-category').forEach(button => {
                    button.addEventListener('click', async () => {
                        const category = button.dataset.category;
                        if (confirm(`Are you sure you want to delete the category "${category}"?`)) {
                            try {
                                const response = await fetch(`/api/categories/${encodeURIComponent(category)}`, {
                                    method: 'DELETE'
                                });
                                if (!response.ok) {
                                    const errorData = await response.json();
                                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                                }
                                await loadCategoryTable();
                                await loadQuickCategorySelect();
                            } catch (error) {
                                console.error('Error deleting category:', error);
                                alert(`Error deleting category: ${error.message}`);
                            }
                        }
                    });
                });

            } catch (error) {
                console.error('Error loading categories:', error);
                container.innerHTML = `<div class="alert alert-danger">Error loading categories: ${error.message}</div>`;
            }
        }
        
        loadCategoryTable();

        async function openEditCategoryModal(category) {
            try {
                const response = await fetch(`/api/categories/${encodeURIComponent(category)}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch category details');
                }
                const data = await response.json();
                
                document.getElementById('editCategoryId').value = category;
                document.getElementById('editCategoryName').value = category;
                document.getElementById('editCategoryPatterns').value = 
                    data.patterns.map(p => p.terms.join(' ')).join('\n');
                
                const modal = new bootstrap.Modal(document.getElementById('editCategoryModal'));
                modal.show();
            } catch (error) {
                console.error('Error loading category details:', error);
                alert('Error loading category details');
            }
        }

        // Load category colors from the server
        const categoryColors = JSON.parse('{{ categoryColors|tojson|safe }}');

        // Utility function to get category color
        function getCategoryColor(category) {
            return categoryColors[category] || '#607D8B';
        }

        // Utility function to convert hex to rgba
        function hexToRgba(hex, alpha = 0.85) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r},${g},${b},${alpha})`;
        }

        // Update chart colors based on category
        function updateChartColors(chart, data) {
            if (data.datasets && data.datasets.length > 0) {
                data.datasets.forEach(dataset => {
                    const category = dataset.label;
                    const color = getCategoryColor(category);
                    dataset.borderColor = color;
                    dataset.backgroundColor = hexToRgba(color);
                    dataset.pointHoverBackgroundColor = color;
                    dataset.pointHoverBorderColor = 'white';
                });
            }
        }
    </script>
</body>
</html>