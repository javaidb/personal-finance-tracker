<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% if bank_branding %}{{ bank_branding.display_name }} - {% endif %}Finance Dashboard | Personal Finance Tracker</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/bank-themes.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0/dist/chartjs-plugin-annotation.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%230d6efd'><path d='M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4z'/></svg>">
    {% if bank_branding %}
    <style>
        :root {
            --bank-primary: {{ bank_branding.colors.primary }};
            --bank-secondary: {{ bank_branding.colors.secondary }};
            --bank-accent: {{ bank_branding.colors.accent }};
            --bank-text: {{ bank_branding.colors.text }};
            --bank-background: {{ bank_branding.colors.background }};
            --bank-success: {{ bank_branding.colors.success }};
            --bank-warning: {{ bank_branding.colors.warning }};
            --bank-error: {{ bank_branding.colors.error }};
        }
    </style>
    {% endif %}
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .dashboard-header {
            background: linear-gradient(135deg, var(--bank-primary, #2c3e50) 0%, var(--bank-secondary, #34495e) 100%);
            color: white;
            padding: 1.5rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
            display: flex;
            align-items: stretch;
        }
        .dashboard-logo-section {
            background-color: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            width: 16.666667%;
            flex-shrink: 0;
            position: relative;
        }
        .dashboard-logo-section::after {
            content: '';
            position: absolute;
            right: -20px;
            top: 0;
            bottom: 0;
            width: 40px;
            background-color: #f8f9fa;
            border-radius: 0 20px 20px 0;
            z-index: 1;
        }
        .dashboard-logo-placeholder {
            width: 300px;
            height: 300px;
            background-color: #e9ecef;
            border: 2px dashed #adb5bd;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
            font-size: 0.8rem;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            z-index: 2;
        }
        .dashboard-logo-placeholder:hover {
            border-color: var(--bank-primary, #007bff);
            background-color: #f8f9fa;
        }
        .dashboard-bank-logo {
            max-width: 300px;
            max-height: 300px;
            object-fit: contain;
            position: relative;
            z-index: 2;
        }
        .dashboard-header-content {
            background: linear-gradient(135deg, var(--bank-primary, #2c3e50) 0%, var(--bank-secondary, #34495e) 100%);
            color: white;
            padding: 1.5rem 0 1.5rem 0;
            flex-grow: 1;
            display: flex;
            align-items: center;
            position: relative;
            z-index: 0;
            width: 100%;
        }
        .dashboard-header-inner {
            position: relative;
            overflow: hidden;
            padding-left: 60px;
            width: 100%;
        }
        .dashboard-header h1 {
            font-size: 2.2rem;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: rgba(255,255,255,0.95);
        }
        .dashboard-header p {
            font-size: 1rem;
            opacity: 0.85;
            margin: 0.5rem 0 0 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .dashboard-header .header-icon {
            font-size: 1.8rem;
            color: rgba(255,255,255,0.9);
        }
        .dashboard-header .header-decoration {
            position: absolute;
            right: -50px;
            top: -50px;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0) 70%);
            border-radius: 50%;
            pointer-events: none;
        }
        .dashboard-header .header-decoration:nth-child(2) {
            right: 10%;
            top: -30px;
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(255,255,255,0.03) 0%, rgba(255,255,255,0) 70%);
        }
        .social-links {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            gap: 1rem;
            align-items: center;
            padding-right: 40px;
            margin-right: 0;
        }
        .social-links a {
            color: rgba(255,255,255,0.8);
            font-size: 1.2rem;
            transition: all 0.2s ease;
            text-decoration: none;
        }
        .social-links a:hover {
            color: white;
            transform: translateY(-2px);
        }
        .social-links .divider {
            width: 1px;
            height: 20px;
            background: rgba(255,255,255,0.2);
        }
        .sidebar {
            background-color: #f8f9fa;
            height: 100vh;
            position: sticky;
            top: 0;
            padding-top: 20px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 30px;
            padding: 10px;
        }
        .card {
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            border: none;
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        .card-header {
            background-color: #fff;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            padding: 15px 20px;
        }
        .card-header h5 {
            margin: 0;
            font-weight: 600;
            color: #333;
        }
        .card-body {
            padding: 20px;
        }
        .nav-link {
            color: #495057;
            border-radius: 0;
            padding: 10px 15px;
        }
        .nav-link.active {
            background-color: #e9ecef;
            font-weight: bold;
        }
        .category-badge {
            font-size: 0.9rem;
            margin: 3px;
            padding: 5px 10px;
            display: inline-block;
            border-radius: 0.25rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .category-badge:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stats-card {
            background-color: #f8f9fa;
            border-left: 4px solid var(--bank-primary, #0d6efd);
            padding: 15px;
            border-radius: 5px;
            transition: transform 0.3s ease;
        }
        .stats-card:hover {
            transform: translateY(-5px);
        }
        .loading-chart {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.8);
            z-index: 10;
            opacity: 1;
            transition: opacity 0.4s ease;
        }
        
        .loading-chart.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--bank-primary, #0d6efd);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Amount Filter Styles */
        .amount-filter-error {
            font-size: 0.875rem;
            margin-top: 0.25rem;
            color: #dc3545;
        }

        .form-control.is-invalid {
            border-color: #dc3545;
            padding-right: calc(1.5em + 0.75rem);
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 12' width='12' height='12' fill='none' stroke='%23dc3545'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right calc(0.375em + 0.1875rem) center;
            background-size: calc(0.75em + 0.375rem) calc(0.75em + 0.375rem);
        }

        .amount-filter-second-value {
            transition: all 0.3s ease-in-out;
        }

        .input-group-text {
            background-color: #f8f9fa;
            border-color: #ced4da;
            color: #6c757d;
        }

        .form-control:focus {
            border-color: var(--bank-primary, #86b7fe);
            box-shadow: 0 0 0 0.25rem rgba(var(--bank-primary-rgb, 13, 110, 253), 0.25);
        }

        .form-control:focus + .input-group-text {
            border-color: var(--bank-primary, #86b7fe);
        }

        .timeline-marker {
            width: 24px;
            height: 24px;
            background: white;
            border: 3px solid var(--bank-primary, #4285f4);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: left 1s ease-in-out;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            cursor: grab;
            user-select: none;
            z-index: 20;
        }
        .timeline-marker:hover {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .timeline-marker.dragging {
            cursor: grabbing;
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
            transition: none;
        }
        .timeline-track {
            height: 8px;
            background: #eef2f7;
            border-radius: 4px;
            position: relative;
            margin: 40px 0;
            cursor: pointer;
        }
        .timeline-track:hover {
            background: #e2e8f0;
        }
        
        /* Bank-specific button styles */
        .btn-bank-primary {
            background-color: var(--bank-primary, #0d6efd);
            border-color: var(--bank-primary, #0d6efd);
            color: white;
        }
        
        .btn-bank-primary:hover {
            background-color: var(--bank-secondary, #0b5ed7);
            border-color: var(--bank-secondary, #0b5ed7);
            color: white;
        }
        
        .btn-outline-bank-primary {
            color: var(--bank-primary, #0d6efd);
            border-color: var(--bank-primary, #0d6efd);
        }
        
        .btn-outline-bank-primary:hover {
            background-color: var(--bank-primary, #0d6efd);
            border-color: var(--bank-primary, #0d6efd);
            color: white;
        }
        
        /* Responsive design for dashboard header */
        @media (max-width: 768px) {
            .dashboard-header {
                flex-direction: column;
            }
            .dashboard-logo-section {
                width: 100%;
                border-bottom: 1px solid #dee2e6;
                padding: 15px;
            }
            .dashboard-logo-section::after {
                display: none;
            }
            .dashboard-header-content {
                padding: 20px 0;
            }
        }
    </style>
</head>
<body {% if bank_branding %}class="{{ bank_branding.theme_class }}"{% endif %}>
    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-md-3 col-lg-2 d-md-block sidebar collapse">
                <div class="position-sticky">
                    <h4 class="p-3">Finance Tracker</h4>
                    <hr>
                    <ul class="nav flex-column">
                        <li class="nav-item">
                            <a class="nav-link active" href="#overview">Overview</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#transactions">Transactions</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#categories">Categories</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#trends">Trends</a>
                        </li>
                    </ul>
                    <hr>
                    <div class="p-3">
                        <a href="/merchants" class="btn btn-bank-primary btn-sm w-100 mb-2">Merchant Management</a>
                        <a href="/" class="btn btn-outline-secondary btn-sm w-100 mb-2">Back to Home</a>
                        <button id="clear-cache-btn" class="btn btn-outline-danger btn-sm w-100">Clear PDF Cache</button>
                    </div>
                </div>
            </div>

            <!-- Main content -->
            <div class="col-md-9 col-lg-10 ms-sm-auto px-md-4">
                <div class="dashboard-header">
                    <div class="dashboard-logo-section">
                        {% if bank_branding and bank_branding.logo_exists %}
                            <img src="{{ bank_branding.logo_path }}" alt="{{ bank_branding.display_name }} Logo" class="dashboard-bank-logo">
                        {% else %}
                            <div class="dashboard-logo-placeholder">
                                <div>
                                    <strong>Bank Logo</strong><br>
                                    <small>Place logo here</small>
                                </div>
                            </div>
                        {% endif %}
                    </div>
                    <div class="dashboard-header-content">
                        <div class="dashboard-header-inner">
                            <div class="header-decoration"></div>
                            <div class="header-decoration"></div>
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <h1>
                                        <i class="bi bi-graph-up-arrow header-icon"></i>
                                        {% if bank_branding %}{{ bank_branding.display_name }} - {% endif %}Finance Dashboard
                                    </h1>
                                    <p>
                                        <i class="bi bi-bar-chart-line"></i>
                                        Track, analyze, and optimize your financial journey
                                    </p>
                                </div>
                                <div class="social-links">
                                    <a href="https://github.com/javaidb" target="_blank" title="GitHub Profile">
                                        <i class="bi bi-github"></i>
                                    </a>
                                    <div class="divider"></div>
                                    <a href="https://github.com/javaidb/personal-finance-tracker" target="_blank" title="Project Repository">
                                        <i class="bi bi-code-square"></i>
                                    </a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Overview Section -->
                <section id="overview" class="mb-5">
                    <h2>Overview</h2>
                    <div id="status-message"></div>

                    <div class="row mt-4">
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header">
                                    <h5>Balance Over Time</h5>
                                </div>
                                <div class="card-body">
                                    <div class="chart-container">
                                        <div id="balanceChartLoader" class="loading-chart">
                                            <div class="loading-spinner"></div>
                                        </div>
                                        <canvas id="balanceChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <h5>Financial Milestones</h5>
                                    <button class="btn btn-sm btn-primary" onclick="openGoalsModal()">
                                        <i class="fas fa-cog"></i> Manage Goals
                                    </button>
                                </div>
                                <div class="card-body">
                                    <div class="chart-container">
                                        <div id="milestoneChartLoader" class="loading-chart">
                                            <div class="loading-spinner"></div>
                                        </div>
                                        <canvas id="milestoneChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="row mt-4">
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header">
                                    <h5>Spending by Category</h5>
                                </div>
                                <div class="card-body">
                                    <div class="chart-container">
                                        <div id="categoryChartLoader" class="loading-chart">
                                            <div class="loading-spinner"></div>
                                        </div>
                                        <canvas id="categoryChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header">
                                    <h5>Income by Category</h5>
                                </div>
                                <div class="card-body">
                                    <div class="chart-container">
                                        <div id="incomeChartLoader" class="loading-chart">
                                            <div class="loading-spinner"></div>
                                        </div>
                                        <canvas id="incomeChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Categories Section -->
                <section id="categories" class="mb-5">
                    <h2>Spending Categories</h2>
                    <div class="card mt-4">
                        <div class="card-header">
                            <h5>All Categories</h5>
                        </div>
                        <div class="card-body">
                            <div id="categories-container" class="d-flex flex-wrap gap-2">
                                <!-- Categories will be populated here -->
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Trends Section -->
                <section id="trends" class="mb-5">
                    <h2>Spending Summary</h2>
                    <div class="card mt-4">
                        <div class="card-header">
                            <h5>Monthly Spending Summary</h5>
                        </div>
                        <div class="card-body">
                            <div class="chart-container">
                                <canvas id="trendsChart"></canvas>
                            </div>
                            <div class="mt-3 text-center">
                                <button id="reset-zoom-btn" class="btn btn-outline-secondary btn-sm me-2">
                                    <i class="bi bi-arrow-clockwise"></i> Reset Zoom
                                </button>
                                <button id="reset-categories-btn" class="btn btn-outline-primary btn-sm">
                                    <i class="bi bi-layers"></i> Reset Category Selection
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Side by Side Analysis Section -->
                    <div class="row mt-4">
                        <!-- Spending Trends Section -->
                        <div class="col-md-6">
                            <div class="card h-100">
                                <div class="card-header">
                                    <h5>Spending Trends</h5>
                                </div>
                                <div class="card-body d-flex flex-column">
                                    <p class="text-muted mb-3">
                                        Analyze your cash flow trends with configurable time and grouping options. Green bars show positive inflows, red bars show negative inflows, and blue bars show the net amount.
                                    </p>
                                    
                                    <!-- Controls -->
                                    <div class="row mb-4">
                                        <div class="col-md-6">
                                            <label for="start-date-trends" class="form-label">Start Date</label>
                                            <input type="month" id="start-date-trends" class="form-control">
                                        </div>
                                        <div class="col-md-6">
                                            <label for="end-date-trends" class="form-label">End Date</label>
                                            <input type="month" id="end-date-trends" class="form-control">
                                        </div>
                                    </div>
                                    <div class="row mb-4">
                                        <div class="col-md-8">
                                            <label for="group-range-select" class="form-label">Group By</label>
                                            <select id="group-range-select" class="form-select">
                                                <option value="month">Month</option>
                                                <option value="quarter">Quarter</option>
                                                <option value="year">Year</option>
                                            </select>
                                        </div>
                                        <div class="col-md-4 d-flex align-items-end">
                                            <button id="apply-trends-filter" class="btn btn-primary">Apply</button>
                                        </div>
                                    </div>
                                    
                                    <div class="chart-container flex-grow-1" style="height: 600px;">
                                        <div id="spendingTrendsChartLoader" class="loading-chart">
                                            <div class="loading-spinner"></div>
                                        </div>
                                        <canvas id="spendingTrendsChart"></canvas>
                                    </div>
                                    
                                    <div class="mt-3">
                                        <small class="text-muted">
                                            <span class="badge bg-success me-1">Green</span> Positive inflow (income)
                                            <span class="badge bg-danger ms-3 me-1">Red</span> Negative inflow (expenses)
                                            <span class="badge bg-primary ms-3 me-1">Blue</span> Net amount
                                        </small>
                                    </div>
                                    
                                    <!-- Category Legend -->
                                    <div class="mt-3">
                                        <h6>Categories</h6>
                                        <small class="text-muted mb-2 d-block">
                                            Click categories to deselect them and visualize net inflow without those categories
                                        </small>
                                        <div id="category-legend" class="d-flex flex-wrap gap-2">
                                            <!-- Categories will be populated here -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- PELT Trend Analysis -->
                        <div class="col-md-6">
                            <div class="card h-100">
                                <div class="card-header">
                                    <h5>Balance Trend Analysis (PELT Algorithm)</h5>
                                </div>
                                <div class="card-body d-flex flex-column">
                                    <p class="text-muted mb-3">
                                        This chart uses the PELT algorithm to detect significant changes in your balance trend. Vertical lines indicate breakpoints between different financial periods.
                                    </p>
                                    <div class="chart-container flex-grow-1" style="height: 300px;">
                                        <canvas id="peltChart"></canvas>
                                    </div>
                                    <div class="mt-4 flex-grow-1 d-flex flex-column">
                                        <h6>Rate of Change Analysis</h6>
                                        <div class="chart-container flex-grow-1" style="height: 250px;">
                                            <canvas id="rateOfChangeChart"></canvas>
                                        </div>
                                        <div class="mt-3">
                                            <small class="text-muted">
                                                <span class="badge bg-success me-1">Green</span> Positive rate (increasing balance)
                                                <span class="badge bg-danger ms-3 me-1">Red</span> Negative rate (decreasing balance)
                                            </small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Transactions Section -->
                <section id="transactions" class="mb-5">
                    <h2>Recent Transactions</h2>
                    <div class="card mt-4">
                        <div class="card-body">
                            <!-- Date Range Filter -->
                            <div class="row mb-4">
                                <div class="col-md-10">
                                    <div class="row g-3">
                                        <div class="col-md-5">
                                            <label for="start-date" class="form-label">Start Date</label>
                                            <input type="date" id="start-date" class="form-control">
                                        </div>
                                        <div class="col-md-5">
                                            <label for="end-date" class="form-label">End Date</label>
                                            <input type="date" id="end-date" class="form-control">
                                        </div>
                                        <div class="col-md-2 d-flex align-items-end">
                                            <button id="apply-date-filter" class="btn btn-primary">Apply Filter</button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Additional Filters -->
                            <div class="row mb-4">
                                <div class="col-md-10">
                                    <div class="row g-3">
                                        <div class="col-md-3">
                                            <label for="description-search" class="form-label">Search Description</label>
                                            <input type="text" id="description-search" class="form-control" placeholder="Enter keywords...">
                                        </div>
                                        <div class="col-md-3">
                                            <label for="account-type-filter" class="form-label">Account Type</label>
                                            <select id="account-type-filter" class="form-select">
                                                <option value="">All Accounts</option>
                                            </select>
                                        </div>
                                        <div class="col-md-3">
                                            <label for="category-filter" class="form-label">Category</label>
                                            <select id="category-filter" class="form-select">
                                                <option value="">All Categories</option>
                                            </select>
                                        </div>
                                        <div class="col-md-3">
                                            <label class="form-label d-block">Time Range</label>
                                            <div class="btn-group" role="group">
                                                <input type="radio" class="btn-check" name="time-range" id="show-recent" autocomplete="off">
                                                <label class="btn btn-outline-secondary" for="show-recent">Recent (3m)</label>
                                                <input type="radio" class="btn-check" name="time-range" id="show-all" autocomplete="off" checked>
                                                <label class="btn btn-outline-secondary" for="show-all">All Time</label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Amount Filter -->
                            <div class="row mb-4">
                                <div class="col-md-10">
                                    <div class="row g-3">
                                        <div class="col-md-4">
                                            <label for="amount-filter-type" class="form-label">Amount Filter</label>
                                            <select id="amount-filter-type" class="form-select">
                                                <option value="">No Filter</option>
                                                <option value="greater">Greater Than</option>
                                                <option value="less">Less Than</option>
                                                <option value="equal">Equal To</option>
                                                <option value="between">Between</option>
                                            </select>
                                        </div>
                                        <div class="col-md-3">
                                            <label for="amount-filter-value" class="form-label">Amount</label>
                                            <div class="input-group">
                                                <span class="input-group-text">$</span>
                                                <input type="number" id="amount-filter-value" class="form-control" placeholder="0.00" step="0.01" min="0">
                                            </div>
                                        </div>
                                        <div class="col-md-3 amount-filter-second-value" style="display: none;">
                                            <label for="amount-filter-value-2" class="form-label">And</label>
                                            <div class="input-group">
                                                <span class="input-group-text">$</span>
                                                <input type="number" id="amount-filter-value-2" class="form-control" placeholder="0.00" step="0.01" min="0">
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mb-2">
                                <div class="col-md-10">
                                    <button id="reset-filters" class="btn btn-secondary">Reset All Filters</button>
                                </div>
                            </div>

                            <div class="table-responsive">
                                <table class="table table-hover">
                                    <thead>
                                        <tr>
                                            <th>Date</th>
                                            <th>Description</th>
                                            <th>Amount</th>
                                            <th>Category</th>
                                            <th>Account</th>
                                            <th>Account Balance</th>
                                            <th>Overall Balance</th>
                                            <th>Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody id="transactions-table-body">
                                        <tr>
                                            <td colspan="7" class="text-center">Loading transactions...</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <div class="d-flex justify-content-between align-items-center mt-3">
                                    <div>
                                        <span id="transaction-count-display">Showing 0 of 0 transactions</span>
                                    </div>
                                    <div>
                                        <button id="prev-page-btn" class="btn btn-sm btn-outline-primary me-2" disabled>Previous</button>
                                        <button id="next-page-btn" class="btn btn-sm btn-outline-primary" disabled>Next</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // Global validation function
        function validateAmountFilters() {
            const amountFilterType = document.getElementById('amount-filter-type')?.value;
            const amountFilterValue = document.getElementById('amount-filter-value');
            const amountFilterValue2 = document.getElementById('amount-filter-value-2');
            const amountFilterSecondValue = document.querySelector('.amount-filter-second-value');

            // If no filter type is selected, return true
            if (!amountFilterType) return true;

            // Reset validation state
            if (amountFilterValue) amountFilterValue.classList.remove('is-invalid');
            if (amountFilterValue2) amountFilterValue2.classList.remove('is-invalid');
            
            // Remove any existing error messages
            const existingError = document.querySelector('.amount-filter-error');
            if (existingError) existingError.remove();

            // Validate first amount value
            const value1 = parseFloat(amountFilterValue?.value);
            if (isNaN(value1) || value1 < 0) {
                if (amountFilterValue) amountFilterValue.classList.add('is-invalid');
                showAmountFilterError('Please enter a valid amount');
                return false;
            }

            // Validate second amount value for "between" filter
            if (amountFilterType === 'between') {
                const value2 = parseFloat(amountFilterValue2?.value);
                if (isNaN(value2) || value2 < 0) {
                    if (amountFilterValue2) amountFilterValue2.classList.add('is-invalid');
                    showAmountFilterError('Please enter a valid second amount');
                    return false;
                }

                // Ensure second value is greater than first value
                if (value2 <= value1) {
                    if (amountFilterValue2) amountFilterValue2.classList.add('is-invalid');
                    showAmountFilterError('Second amount must be greater than first amount');
                    return false;
                }
            }

            return true;
        }

        function showAmountFilterError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'amount-filter-error text-danger mt-2';
            errorDiv.textContent = message;
            const secondValueContainer = document.querySelector('.amount-filter-second-value');
            if (secondValueContainer) {
                secondValueContainer.insertAdjacentElement('afterend', errorDiv);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Set up status display
            const statusMessage = document.getElementById('status-message');
            if (statusMessage) {
                statusMessage.innerHTML = '<div class="alert alert-info">Loading your financial data...</div>';
            }
            
            // Load filter options
            loadFilterOptions();
            
            // Set default date range for spending trends (empty start date to take entire range, end date to current month)
            const startDateTrends = document.getElementById('start-date-trends');
            const endDateTrends = document.getElementById('end-date-trends');
            if (startDateTrends && endDateTrends) {
                const now = new Date();
                
                // Leave start date empty to take entire range
                startDateTrends.value = '';
                // Set end date to current month
                endDateTrends.value = now.toISOString().slice(0, 7);
            }
            
            // Fetch data and populate the dashboard - ensure categories is loaded first
            Promise.all([
                fetchCategories(),  // Get categories first for color consistency
                fetchBalanceChart(),
                fetchBalanceData(), // Add milestone chart initialization
                fetchTransactions(),
                fetchMonthlyTrends(),
                fetchPeltAnalysis(),
                fetchSpendingTrends() // Add spending trends chart
            ])
            .then(() => {
                if (statusMessage) {
                    statusMessage.innerHTML = '<div class="alert alert-success">Data loaded successfully!</div>';
                    // Hide status message after 3 seconds
                    setTimeout(() => {
                        statusMessage.innerHTML = '';
                    }, 3000);
                }
            })
            .catch(error => {
                if (statusMessage) {
                    statusMessage.innerHTML = `<div class="alert alert-danger">Error loading data: ${error.message}</div>`;
                }
            });
            
            // Event listeners for filters
            const applyDateFilter = document.getElementById('apply-date-filter');
            if (applyDateFilter) applyDateFilter.addEventListener('click', fetchTransactions);
            const descriptionSearch = document.getElementById('description-search');
            if (descriptionSearch) descriptionSearch.addEventListener('input', debounce(fetchTransactions, 300));
            
            // Event listeners for spending trends controls
            const applyTrendsFilter = document.getElementById('apply-trends-filter');
            const groupRangeSelect = document.getElementById('group-range-select');
            if (applyTrendsFilter) applyTrendsFilter.addEventListener('click', fetchSpendingTrends);
            if (groupRangeSelect) groupRangeSelect.addEventListener('change', fetchSpendingTrends);
            

            const accountTypeFilter = document.getElementById('account-type-filter');
            if (accountTypeFilter) accountTypeFilter.addEventListener('change', fetchTransactions);
            const categoryFilter = document.getElementById('category-filter');
            if (categoryFilter) categoryFilter.addEventListener('change', fetchTransactions);
            const showRecent = document.getElementById('show-recent');
            if (showRecent) showRecent.addEventListener('change', fetchTransactions);
            const showAll = document.getElementById('show-all');
            if (showAll) showAll.addEventListener('change', fetchTransactions);
            const resetFiltersBtn = document.getElementById('reset-filters');
            if (resetFiltersBtn) resetFiltersBtn.addEventListener('click', resetFilters);

            // Amount filter event listeners
            const amountFilterType = document.getElementById('amount-filter-type');
            const amountFilterValue = document.getElementById('amount-filter-value');
            const amountFilterValue2 = document.getElementById('amount-filter-value-2');
            const amountFilterSecondValue = document.querySelector('.amount-filter-second-value');

            if (amountFilterType) {
                amountFilterType.addEventListener('change', function() {
                    // Show/hide second value input for "between" filter
                    if (this.value === 'between') {
                        amountFilterSecondValue.style.display = 'block';
                    } else {
                        amountFilterSecondValue.style.display = 'none';
                        amountFilterValue2.value = ''; // Clear second value when not needed
                    }
                    validateAmountFilters();
                    fetchTransactions();
                });
            }

            if (amountFilterValue) {
                amountFilterValue.addEventListener('input', function() {
                    validateAmountFilters();
                    debounce(fetchTransactions, 300)();
                });
            }

            if (amountFilterValue2) {
                amountFilterValue2.addEventListener('input', function() {
                    validateAmountFilters();
                    debounce(fetchTransactions, 300)();
                });
            }

            // Event listener for cache clearing
            const clearCacheBtn = document.getElementById('clear-cache-btn');
            if (clearCacheBtn) clearCacheBtn.addEventListener('click', function() {
                clearPDFCache();
            });
            
            // Navigation tabs
            const navLinks = document.querySelectorAll('.nav-link');
            navLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    // Remove active class from all links
                    navLinks.forEach(l => l.classList.remove('active'));
                    // Add active class to clicked link
                    this.classList.add('active');
                    // Show the corresponding section
                    const targetId = this.getAttribute('href').substring(1);
                    document.querySelectorAll('section').forEach(section => {
                        section.style.display = 'none';
                    });
                    const targetSection = document.getElementById(targetId);
                    if (targetSection) targetSection.style.display = 'block';
                });
            });
            
            // Initialize pagination
            if (typeof initPagination === 'function') initPagination();

            // Category Management Functions
            if (typeof loadCategoryTable === 'function') loadCategoryTable();

            // Event Listeners for Category Management
            const saveCategoryBtn = document.getElementById('saveCategoryBtn');
            if (saveCategoryBtn) saveCategoryBtn.addEventListener('click', async () => {
                const name = document.getElementById('categoryName')?.value.trim();
                const patterns = document.getElementById('categoryPatterns')?.value
                    .split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0);
                
                if (!name) {
                    alert('Category name is required');
                    return;
                }
                
                try {
                    const response = await fetch('/api/categories', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            name: name,
                            patterns: patterns.map(p => ({
                                terms: p.split(' '),
                                dateAdded: new Date().toISOString(),
                                lastUpdated: new Date().toISOString(),
                                matchCount: 0
                            }))
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to add category');
                    }
                    
                    const modal = bootstrap.Modal.getInstance(document.getElementById('addCategoryModal'));
                    if (modal) modal.hide();
                    document.getElementById('categoryName').value = '';
                    document.getElementById('categoryPatterns').value = '';
                    await Promise.all([
                        loadCategoryTable(),
                        fetchCategories()
                    ]);
                } catch (error) {
                    console.error('Error saving category:', error);
                    alert('Error saving category');
                }
            });

            const updateCategoryBtn = document.getElementById('updateCategoryBtn');
            if (updateCategoryBtn) updateCategoryBtn.addEventListener('click', async () => {
                const id = document.getElementById('editCategoryId')?.value;
                const name = document.getElementById('editCategoryName')?.value.trim();
                const patterns = document.getElementById('editCategoryPatterns')?.value
                    .split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0);
                
                if (!name) {
                    alert('Category name is required');
                    return;
                }
                
                try {
                    const response = await fetch(`/api/categories/${encodeURIComponent(id)}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            name: name,
                            patterns: patterns.map(p => ({
                                terms: p.split(' '),
                                dateAdded: new Date().toISOString(),
                                lastUpdated: new Date().toISOString(),
                                matchCount: 0
                            }))
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to update category');
                    }
                    
                    const modal = bootstrap.Modal.getInstance(document.getElementById('editCategoryModal'));
                    if (modal) modal.hide();
                    await Promise.all([
                        loadCategoryTable(),
                        fetchCategories()
                    ]);
                } catch (error) {
                    console.error('Error updating category:', error);
                    alert('Error updating category');
                }
            });

            const deleteCategoryBtn = document.getElementById('deleteCategoryBtn');
            if (deleteCategoryBtn) deleteCategoryBtn.addEventListener('click', async () => {
                const id = document.getElementById('editCategoryId')?.value;
                if (!confirm(`Are you sure you want to delete the category "${id}"?`)) {
                    return;
                }
                
                try {
                    const response = await fetch(`/api/categories/${encodeURIComponent(id)}`, {
                        method: 'DELETE'
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to delete category');
                    }
                    
                    const modal = bootstrap.Modal.getInstance(document.getElementById('editCategoryModal'));
                    if (modal) modal.hide();
                    await Promise.all([
                        loadCategoryTable(),
                        fetchCategories()
                    ]);
                } catch (error) {
                    console.error('Error deleting category:', error);
                    alert('Error deleting category');
                }
            });

            // Load categories into quick keyword select
            if (typeof loadQuickCategorySelect === 'function') loadQuickCategorySelect();

            // Handle quick keyword form submission
            const quickKeywordForm = document.getElementById('quickKeywordForm');
            if (quickKeywordForm) quickKeywordForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const category = document.getElementById('quickCategorySelect')?.value;
                const keyword = document.getElementById('quickKeyword')?.value.trim();
                
                if (!category || !keyword) {
                    alert('Please select a category and enter a keyword');
                    return;
                }
                
                try {
                    const response = await fetch(`/api/categories/${encodeURIComponent(category)}`);
                    if (!response.ok) {
                        throw new Error('Failed to fetch category details');
                    }
                    
                    const data = await response.json();
                    const patterns = data.patterns || [];
                    
                    // Add new pattern
                    patterns.push({
                        terms: keyword.split(' '),
                        dateAdded: new Date().toISOString(),
                        lastUpdated: new Date().toISOString(),
                        matchCount: 0
                    });
                    
                    // Update category
                    const updateResponse = await fetch(`/api/categories/${encodeURIComponent(category)}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            name: category,
                            patterns: patterns
                        })
                    });
                    
                    if (!updateResponse.ok) {
                        throw new Error('Failed to update category');
                    }
                    
                    // Clear form and show success message
                    document.getElementById('quickKeyword').value = '';
                    alert('Keyword added successfully!');
                    
                    // Refresh categories
                    await Promise.all([
                        loadCategoryTable(),
                        fetchCategories()
                    ]);
                } catch (error) {
                    console.error('Error adding keyword:', error);
                    alert('Error adding keyword');
                }
            });

            // Load quick category select on page load
            if (typeof loadQuickCategorySelect === 'function') loadQuickCategorySelect();
        });
        
        // Debounce function for search input
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Load filter options
        function loadFilterOptions() {
            fetch('/api/filter-options')
                .then(response => response.json())
                .then(data => {
                    const accountTypeSelect = document.getElementById('account-type-filter');
                    const categorySelect = document.getElementById('category-filter');
                    
                    // Populate account types
                    data.account_types.forEach(type => {
                        const option = document.createElement('option');
                        option.value = type;
                        option.textContent = type;
                        accountTypeSelect.appendChild(option);
                    });
                    
                    // Populate categories
                    data.categories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = category;
                        option.textContent = category;
                        categorySelect.appendChild(option);
                    });
                })
                .catch(error => {
                    console.error('Error loading filter options:', error);
                });
        }
        
        // Reset all filters
        function resetFilters() {
            document.getElementById('start-date').value = '';
            document.getElementById('end-date').value = '';
            document.getElementById('description-search').value = '';
            document.getElementById('account-type-filter').value = '';
            document.getElementById('category-filter').value = '';
            document.getElementById('show-all').checked = true;
            // Reset amount filters
            document.getElementById('amount-filter-type').value = '';
            document.getElementById('amount-filter-value').value = '';
            document.getElementById('amount-filter-value-2').value = '';
            document.querySelector('.amount-filter-second-value').style.display = 'none';
            fetchTransactions();
        }
        
        // Transactions page variables
        let allTransactions = [];
        let currentPage = 1;
        const transactionsPerPage = 20;
        
        async function fetchTransactions() {
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const description = document.getElementById('description-search').value;
            const accountType = document.getElementById('account-type-filter').value;
            const category = document.getElementById('category-filter').value;
            const showRecent = document.getElementById('show-recent').checked;
            
            // Get amount filter values
            const amountFilterType = document.getElementById('amount-filter-type').value;
            const amountFilterValue = parseFloat(document.getElementById('amount-filter-value').value) || 0;
            const amountFilterValue2 = parseFloat(document.getElementById('amount-filter-value-2').value) || 0;
            
            let url = '/api/transactions';
            const params = new URLSearchParams();
            
            if (startDate) params.append('start_date', startDate);
            if (endDate) params.append('end_date', endDate);
            if (description) params.append('description', description);
            if (accountType) params.append('account_type', accountType);
            if (category) params.append('category', category);
            params.append('show_recent', showRecent);
            
            // Add amount filter parameters
            if (amountFilterType) {
                params.append('amount_filter_type', amountFilterType);
                params.append('amount_filter_value', amountFilterValue);
                if (amountFilterType === 'between') {
                    params.append('amount_filter_value_2', amountFilterValue2);
                }
            }
            
            // Append parameters to URL if they exist
            url += '?' + params.toString();
            
            document.getElementById('transactions-table-body').innerHTML = '<tr><td colspan="7" class="text-center">Loading transactions...</td></tr>';
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Failed to fetch transactions');
                }
                const data = await response.json();
                
                if (Array.isArray(data)) {
                    // Apply amount filtering client-side for better UX
                    allTransactions = filterTransactionsByAmount(data, amountFilterType, amountFilterValue, amountFilterValue2);
                    
                    // Reset current page to 1 when filters change
                    currentPage = 1;
                    
                    // Display transactions and update pagination
                    displayTransactions(currentPage);
                    document.getElementById('transaction-count-display').innerText = 
                        `Showing ${Math.min(transactionsPerPage, allTransactions.length)} of ${allTransactions.length} transactions`;
                    updatePaginationButtons();
                } else {
                    throw new Error('Invalid data format received');
                }
            } catch (error) {
                console.error('Error fetching transactions:', error);
                document.getElementById('transactions-table-body').innerHTML = 
                    '<tr><td colspan="7" class="text-center text-danger">Error loading transactions: ' + error.message + '</td></tr>';
            }
        }

        // Helper function to filter transactions by amount
        function filterTransactionsByAmount(transactions, filterType, value1, value2) {
            if (!filterType || !validateAmountFilters()) return transactions;

            return transactions.filter(transaction => {
                const amount = Math.abs(parseFloat(transaction.Amount));
                
                switch (filterType) {
                    case 'greater':
                        return amount > value1;
                    case 'less':
                        return amount < value1;
                    case 'equal':
                        return Math.abs(amount - value1) < 0.01; // Using small epsilon for float comparison
                    case 'between':
                        const min = Math.min(value1, value2);
                        const max = Math.max(value1, value2);
                        return amount >= min && amount <= max;
                    default:
                        return true;
                }
            });
        }
            
        function displayTransactions(page) {
            const startIndex = (page - 1) * transactionsPerPage;
            const endIndex = startIndex + transactionsPerPage;
            const pageTransactions = allTransactions.slice(startIndex, endIndex);
            
            const tableBody = document.getElementById('transactions-table-body');
            if (!tableBody) return;
            tableBody.innerHTML = '';
            
            if (pageTransactions.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="7" class="text-center">No transactions found in this date range.</td></tr>';
                return;
            }
            
            // Define aesthetic colors for different account types
            const accountTypeColors = {
                'Chequing': 'bg-success bg-opacity-75 text-white',  // Green
                'Savings': 'bg-info bg-opacity-75 text-white',      // Blue
                'Credit': 'bg-dark bg-opacity-75 text-white'        // Aesthetic black
            };
            
            pageTransactions.forEach(transaction => {
                const row = document.createElement('tr');
                
                // Format date
                const date = new Date(transaction.DateTime);
                const formattedDate = date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                
                // Format amount with sign and color
                const amount = parseFloat(transaction.Amount);
                const formattedAmount = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(amount);
                
                // Get account type style
                const accountTypeClass = accountTypeColors[transaction['Account Type']] || 'bg-secondary';
                
                // Get category color from the global categoryColors object
                const categoryColor = window.categoryColors && window.categoryColors[transaction.Classification]
                    ? window.categoryColors[transaction.Classification]
                    : '#6c757d'; // Default grey if no color found
                
                // Create a unique identifier for the transaction using DateTime and Amount
                const transactionDate = new Date(transaction.DateTime);
                const transactionDateStr = transactionDate.toISOString().split('T')[0]; // Get YYYY-MM-DD format
                const transactionId = `${transactionDateStr}_${transaction.Amount}`;
                
                row.innerHTML = `
                    <td>${formattedDate}</td>
                    <td>${transaction.Details || ''}</td>
                    <td class="${amount < 0 ? 'text-danger' : 'text-success'}">${formattedAmount}</td>
                    <td>
                        <div class="d-flex align-items-center">
                            <span class="badge me-2" style="background-color: ${categoryColor}">${transaction.Classification || 'uncategorized'}</span>
                            <div class="dropdown">
                                <button class="btn btn-link btn-sm p-0 text-muted" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
                                        <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
                                    </svg>
                                </button>
                                <ul class="dropdown-menu dropdown-menu-end" data-transaction-id="${transactionId}">
                                    <li><h6 class="dropdown-header">Change Category</h6></li>
                                    ${Object.keys(window.categoryColors || {}).map(category => `
                                        <li>
                                            <a class="dropdown-item" href="#" data-category="${category}">
                                                <span class="badge me-2" style="background-color: ${window.categoryColors[category]}">${category}</span>
                                            </a>
                                        </li>
                                    `).join('')}
                                    <li><hr class="dropdown-divider"></li>
                                    <li>
                                        <a class="dropdown-item text-danger" href="#" data-action="reset">
                                            <i class="bi bi-x-circle me-2"></i>Reset to Default
                                        </a>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </td>
                    <td><span class="badge ${accountTypeClass}">${transaction['Account Type'] || ''}</span></td>
                    <td>${transaction.account_balance !== null ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(transaction.account_balance) : '-'}</td>
                    <td>${transaction.running_balance !== null ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(transaction.running_balance) : '-'}</td>
                `;
                
                // Add event listeners for category selection
                const dropdown = row.querySelector('.dropdown-menu');
                dropdown.addEventListener('click', async function(e) {
                    e.preventDefault();
                    const target = e.target.closest('.dropdown-item');
                    if (!target) return;
                    
                    const transactionId = this.dataset.transactionId;
                    const action = target.dataset.action;
                    
                    try {
                        if (action === 'reset') {
                            const response = await fetch('/api/transactions/manual-category', {
                                method: 'DELETE',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    transaction_id: transactionId
                                })
                            });
                            
                            if (!response.ok) {
                                throw new Error('Failed to reset category');
                            }
                        } else {
                            const category = target.dataset.category;
                            const response = await fetch('/api/transactions/manual-category', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    transaction_id: transactionId,
                                    category: category
                                })
                            });
                            
                            if (!response.ok) {
                                throw new Error('Failed to update category');
                            }
                        }
                        
                        // Refresh the transactions to show the new category
                        await fetchTransactions();
                        
                        // Refresh the categories display
                        await fetchCategories();
                        
                    } catch (error) {
                        console.error('Error updating category:', error);
                        alert('Error updating category: ' + error.message);
                    }
                });
                
                tableBody.appendChild(row);
            });
        }
            
        function initPagination() {
            document.getElementById('prev-page-btn').addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    displayTransactions(currentPage);
                    updatePaginationButtons();
                }
            });
            
            document.getElementById('next-page-btn').addEventListener('click', () => {
                const maxPages = Math.ceil(allTransactions.length / transactionsPerPage);
                if (currentPage < maxPages) {
                    currentPage++;
                    displayTransactions(currentPage);
                    updatePaginationButtons();
                }
            });
        }
            
        function updatePaginationButtons() {
            const prevBtn = document.getElementById('prev-page-btn');
            const nextBtn = document.getElementById('next-page-btn');
            const maxPages = Math.ceil(allTransactions.length / transactionsPerPage);
            
            prevBtn.disabled = currentPage === 1;
            nextBtn.disabled = currentPage === maxPages || maxPages === 0;
        }
        
        function clearPDFCache() {
            if (!confirm('Are you sure you want to clear the PDF cache? You will need to reprocess all PDFs next time.')) {
                return;
            }
            
            fetch('/api/clear_cache', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('PDF cache cleared successfully');
                        // Force a hard reload of the page to ensure fresh data
                        window.location.href = window.location.href;
                    } else {
                        alert('Error: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('Error clearing cache:', error);
                    alert('Error clearing cache. See console for details.');
                });
        }
        
        async function fetchBalanceChart() {
            try {
                const response = await fetch('/api/balance-chart');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                renderBalanceChart(data);
                return data;
            } catch (error) {
                console.error('Error fetching balance chart data:', error);
                throw error;
            }
        }
        
        async function fetchPeltAnalysis() {
            try {
                const response = await fetch('/api/pelt-analysis');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                renderPeltChart(data);
                renderRateOfChangeChart(data.rateOfChange);
                return data;
            } catch (error) {
                console.error('Error fetching PELT analysis data:', error);
                throw error;
            }
        }
        
        async function fetchSpendingTrends() {
            try {
                const startDate = document.getElementById('start-date-trends')?.value;
                const endDate = document.getElementById('end-date-trends')?.value;
                const groupRange = document.getElementById('group-range-select')?.value || 'month';
                
                // Get selected categories
                const selectedCategories = getSelectedCategories();
                
                const params = new URLSearchParams();
                if (startDate) params.append('start_date', startDate);
                if (endDate) params.append('end_date', endDate);
                params.append('group_range', groupRange);
                
                // Add selected categories
                selectedCategories.forEach(category => {
                    params.append('categories', category);
                });
                
                const response = await fetch(`/api/spending-trends?${params.toString()}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                renderSpendingTrendsChart(data);
                
                renderCategoryLegend(data.available_categories || []);
                return data;
            } catch (error) {
                console.error('Error fetching spending trends data:', error);
                // Hide loading spinner on error
                const loader = document.getElementById('spendingTrendsChartLoader');
                if (loader) loader.classList.add('hidden');
                throw error;
            }
        }
        
        function renderBalanceChart(data) {
            const ctx = document.getElementById('balanceChart').getContext('2d');
            
            // Clean up any existing chart
            const existingChart = Chart.getChart(ctx.canvas);
            if (existingChart) {
                existingChart.destroy();
            }

            // Create gradients for both datasets
            const gradient1 = ctx.createLinearGradient(0, 0, 0, 400);
            gradient1.addColorStop(0, 'rgba(187, 37, 37, 0.3)');  // Semi-transparent red at top
            gradient1.addColorStop(1, 'rgba(187, 37, 37, 0.01)'); // Almost transparent at bottom

            const gradient2 = ctx.createLinearGradient(0, 0, 0, 400);
            gradient2.addColorStop(0, 'rgba(76, 175, 80, 0.3)');  // Semi-transparent green at top
            gradient2.addColorStop(1, 'rgba(76, 175, 80, 0.01)'); // Almost transparent at bottom
            
            // Enhance the datasets with better styling
            if (data.datasets && data.datasets.length > 0) {
                // Style for regular balance
                data.datasets[0].borderColor = 'rgba(187, 37, 37, 0.8)';
                data.datasets[0].backgroundColor = gradient1;
                data.datasets[0].borderWidth = 2;
                data.datasets[0].pointRadius = 0;
                data.datasets[0].pointHoverRadius = 6;
                data.datasets[0].pointHoverBackgroundColor = 'rgba(187, 37, 37, 1)';
                data.datasets[0].pointHoverBorderColor = 'white';
                data.datasets[0].pointHoverBorderWidth = 2;
                data.datasets[0].tension = 0.3;
                data.datasets[0].fill = true;

                // Style for balance + investments
                if (data.datasets[1]) {
                    data.datasets[1].borderColor = 'rgba(76, 175, 80, 0.8)';
                    data.datasets[1].backgroundColor = gradient2;
                    data.datasets[1].borderWidth = 2;
                    data.datasets[1].pointRadius = 0;
                    data.datasets[1].pointHoverRadius = 6;
                    data.datasets[1].pointHoverBackgroundColor = 'rgba(76, 175, 80, 1)';
                    data.datasets[1].pointHoverBorderColor = 'white';
                    data.datasets[1].pointHoverBorderWidth = 2;
                    data.datasets[1].tension = 0.3;
                    data.datasets[1].fill = true;
                }
            }
            
            // Create chart with improved options
            const chart = new Chart(ctx, {
                type: 'line',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 1500,
                        easing: 'easeOutQuart',
                        onComplete: function() {
                            document.getElementById('balanceChartLoader').classList.add('hidden');
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    scales: {
                        x: {
                            type: 'category',
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxTicksLimit: 8,
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 11
                                }
                            }
                        },
                        y: {
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.05)',
                                drawBorder: false
                            },
                            ticks: {
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 11
                                },
                                callback: function(value) {
                                    return new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD',
                                        maximumFractionDigits: 0
                                    }).format(value);
                                }
                            },
                            title: {
                                display: true,
                                text: 'Balance',
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 12,
                                    weight: '500'
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                font: {
                                    family: 'Inter',
                                    size: 12
                                },
                                usePointStyle: true,
                                pointStyle: 'circle',
                                padding: 20
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.7)',
                            titleFont: {
                                family: 'Inter',
                                size: 12
                            },
                            bodyFont: {
                                family: 'Inter',
                                size: 12
                            },
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD'
                                    }).format(context.raw);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        async function fetchCategories() {
            try {
                const response = await fetch('/api/categories');
                if (!response.ok) {
                    throw new Error('Failed to fetch categories');
                }
                
                const categories = await response.json();
                
                if (categories.error) {
                    throw new Error(categories.error);
                }
                
                // Render the categories list
                renderCategories(categories.counts || {}, categories.colors || {});
                
                // Render both spending and income charts
                renderCategoryChart('categoryChart', categories.spending || {}, categories.colors || {}, 'Spending');
                renderCategoryChart('incomeChart', categories.income || {}, categories.colors || {}, 'Income');
                
                // Show messages if there's no data
                if (categories.has_spending_data === false) {
                    console.warn("No spending data available - check that you have transactions with negative amounts");
                    const chartContainer = document.querySelector('#categoryChart').parentNode;
                    const warningEl = document.createElement('div');
                    warningEl.className = 'small text-warning text-center mt-2';
                    warningEl.textContent = 'Note: No expense transactions found to display in chart';
                    chartContainer.appendChild(warningEl);
                }
                
                if (categories.has_income_data === false) {
                    console.warn("No income data available - check that you have transactions with positive amounts");
                    const chartContainer = document.querySelector('#incomeChart').parentNode;
                    const warningEl = document.createElement('div');
                    warningEl.className = 'small text-warning text-center mt-2';
                    warningEl.textContent = 'Note: No income transactions found to display in chart';
                    chartContainer.appendChild(warningEl);
                }
                
                // Store colors globally for other charts to use
                window.categoryColors = categories.colors || {};
                
                return true;
            } catch (error) {
                console.error('Error fetching categories:', error);
                document.getElementById('categories-container').innerHTML = 
                    '<div class="alert alert-danger w-100">Failed to load categories: ' + error.message + '</div>';
                renderCategoryChart('categoryChart', null); // Ensure spending chart shows the "no data" state
                renderCategoryChart('incomeChart', null); // Ensure income chart shows the "no data" state
                return false;
            }
        }
        
        function renderCategories(categories, categoryColors) {
            const container = document.getElementById('categories-container');
            if (!container) {
                console.error('Categories container not found');
                return;
            }
            
            if (Object.keys(categories).length === 0) {
                container.innerHTML = '<p class="text-center w-100">No categories found</p>';
                return;
            }
            
            let html = '';
            for (const category in categories) {
                const bgColor = categoryColors && categoryColors[category] ? categoryColors[category] : '#607D8B';
                const count = categories[category];
                html += `
                    <div class="category-badge" style="background-color: ${bgColor}; color: white; padding: 5px 10px; border-radius: 15px; margin: 3px; font-size: 0.9rem;">
                        ${category}: ${count}
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        function renderCategoryChart(canvasId, categoryData, categoryColors, chartType) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            // If we already have a chart, destroy it to prevent duplicates
            const existingChart = Chart.getChart(ctx.canvas);
            if (existingChart) {
                existingChart.destroy();
            }
            
            // If no real data yet, show placeholder
            if (!categoryData || Object.keys(categoryData).length === 0) {
                new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: [`No ${chartType.toLowerCase()} data available`],
                        datasets: [{
                            data: [1],
                            backgroundColor: ['#f0f0f0'],
                            borderColor: '#e0e0e0',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        cutout: '70%',
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: {
                                    font: {
                                        family: 'Inter',
                                        size: 12
                                    },
                                    padding: 15,
                                    color: '#666'
                                }
                            },
                            tooltip: {
                                enabled: false
                            }
                        },
                        animation: {
                            animateScale: true,
                            animateRotate: true,
                            duration: 1000,
                            easing: 'easeOutQuart',
                            onComplete: function() {
                                // Hide loader even for placeholder
                                document.getElementById(`${canvasId}Loader`).classList.add('hidden');
                            }
                        }
                    }
                });
                return;
            }
            
            // Sort categories by amount (descending)
            const sortedEntries = Object.entries(categoryData)
                .sort((a, b) => b[1] - a[1]);
            
            const labels = sortedEntries.map(entry => entry[0]);
            const data = sortedEntries.map(entry => entry[1]);
            
            // Calculate total for percentages
            const total = data.reduce((sum, value) => sum + value, 0);
            
            // Use provided category colors or fallback to defaults
            const colors = labels.map(label => 
                categoryColors && categoryColors[label] ? categoryColors[label] : '#607D8B'
            );
            
            // Add slight transparency to colors for better aesthetic
            const backgroundColors = colors.map(color => {
                // If color is hex, convert to rgba
                if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r},${g},${b},0.85)`;
                }
                // If already rgba, just return
                return color;
            });
            
            // Slightly darker colors for hover state
            const hoverColors = backgroundColors.map(color => {
                if (color.startsWith('rgba')) {
                    return color.replace('0.85', '1');
                }
                return color;
            });
            
            new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors,
                        hoverBackgroundColor: hoverColors,
                        borderColor: 'white',
                        borderWidth: 2,
                        hoverBorderWidth: 0,
                        hoverOffset: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '60%',
                    layout: {
                        padding: 15
                    },
                    animation: {
                        animateScale: true,
                        animateRotate: true,
                        duration: 1000,
                        easing: 'easeOutQuart',
                        onComplete: function() {
                            // Hide loader
                            document.getElementById(`${canvasId}Loader`).classList.add('hidden');
                            
                            // Add total text in the center
                            const chartArea = document.querySelector(`#${canvasId}`).parentNode;
                            let centerText = chartArea.querySelector('.doughnut-center-text');
                            
                            if (!centerText) {
                                centerText = document.createElement('div');
                                centerText.className = 'doughnut-center-text';
                                centerText.style.position = 'absolute';
                                centerText.style.top = '50%';
                                centerText.style.left = '50%';
                                centerText.style.transform = 'translate(-50%, -50%)';
                                centerText.style.textAlign = 'center';
                                centerText.style.pointerEvents = 'none';
                                centerText.style.fontFamily = 'Inter, sans-serif';
                                
                                chartArea.style.position = 'relative';
                                chartArea.appendChild(centerText);
                            }
                            
                            const formattedTotal = new Intl.NumberFormat('en-US', {
                                style: 'currency',
                                currency: 'USD',
                                maximumFractionDigits: 0
                            }).format(total);
                            
                            centerText.innerHTML = `
                                <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Total ${chartType}</div>
                                <div style="font-size: 18px; font-weight: 600; color: #333;">${formattedTotal}</div>
                            `;
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                font: {
                                    family: 'Inter',
                                    size: 12
                                },
                                padding: 15,
                                usePointStyle: true,
                                pointStyle: 'circle',
                                color: '#666',
                                // Limit the number of legend items shown if there are too many
                                filter: function(legendItem, data) {
                                    // Only show top categories that make up 95% of total plus "Other"
                                    const index = legendItem.index;
                                    const value = data.datasets[0].data[index];
                                    const percentage = (value / total) * 100;
                                    
                                    // Always show top 6 categories regardless of percentage
                                    if (index < 6) return true;
                                    
                                    // Show categories with at least 1% of total
                                    return percentage >= 1;
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.7)',
                            titleFont: {
                                family: 'Inter',
                                size: 13,
                                weight: 'bold'
                            },
                            bodyFont: {
                                family: 'Inter',
                                size: 12
                            },
                            padding: 12,
                            cornerRadius: 6,
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.raw || 0;
                                    const percentage = Math.round((value / total) * 100);
                                    return `${label}: ${new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD'
                                    }).format(value)} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderTrendsChart(data = null) {
            const ctx = document.getElementById('trendsChart').getContext('2d');
            
            // If we already have a chart, destroy it to prevent duplicates
            const existingChart = Chart.getChart(ctx.canvas);
            if (existingChart) {
                existingChart.destroy();
            }
            
            // If no real data yet, show placeholder
            if (!data) {
                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Loading...'],
                        datasets: [{
                            label: 'Monthly Net Transactions',
                            data: [0],
                            backgroundColor: '#cccccc'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
                return;
            }
            
            // Apply consistent colors to datasets if available
            if (window.categoryColors) {
                data.datasets.forEach(dataset => {
                    if (window.categoryColors[dataset.label]) {
                        dataset.backgroundColor = window.categoryColors[dataset.label];
                    }
                });
            }
            
            // Create chart with improved options
            const trendsChart = new Chart(ctx, {
                type: 'bar',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.raw || 0;
                                    const sign = value >= 0 ? '+' : '';
                                    return `${label}: ${sign}${new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD'
                                    }).format(value)}`;
                                }
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                // Limit the number of legends displayed
                                filter: function(legendItem, data) {
                                    // Only show categories with significant transactions
                                    const dataset = data.datasets[legendItem.datasetIndex];
                                    const total = dataset.data.reduce((a, b) => Math.abs(a) + Math.abs(b), 0);
                                    return total > 100; // Only show categories with more than $100 total
                                }
                            },
                            onClick: function(e, legendItem, legend) {
                                // Handle double-click logic
                                const now = Date.now();
                                const lastClick = this.lastClickTime || 0;
                                const doubleClickThreshold = 300; // milliseconds
                                
                                if (now - lastClick < doubleClickThreshold) {
                                    // Double click detected - show only this category
                                    const clickedIndex = legendItem.datasetIndex;
                                    const datasets = legend.chart.data.datasets;
                                    
                                    // Show only this category
                                    datasets.forEach((dataset, index) => {
                                        legend.chart.getDatasetMeta(index).hidden = (index !== clickedIndex);
                                    });
                                    
                                    legend.chart.update();
                                    this.lastClickTime = 0; // Reset for next interaction
                                    return false; // Prevent default behavior for double-click
                                } else {
                                    // Single click - use default behavior
                                    this.lastClickTime = now;
                                    // Execute the default legend click behavior manually
                                    const meta = legend.chart.getDatasetMeta(legendItem.datasetIndex);
                                    meta.hidden = !meta.hidden;
                                    legend.chart.update();
                                    return false; // Prevent default behavior since we handled it manually
                                }
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x',
                                drag: {
                                    enabled: true,
                                    backgroundColor: 'rgba(0,0,0,0.1)',
                                    borderColor: 'rgba(0,0,0,0.3)',
                                    borderWidth: 1,
                                    threshold: 10
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                autoSkip: true,
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: false, // Allow negative values
                            title: {
                                display: true,
                                text: 'Net Amount ($)'
                            },
                            grid: {
                                color: function(context) {
                                    if (context.tick.value === 0) {
                                        return 'rgba(0, 0, 0, 0.5)';
                                    }
                                    return 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    if (context.tick.value === 0) {
                                        return 2;
                                    }
                                    return 1;
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD',
                                        maximumFractionDigits: 0
                                    }).format(value);
                                }
                            }
                        }
                    }
                }
            });
            // Add reset zoom functionality
            const resetZoomBtn = document.getElementById('reset-zoom-btn');
            if (resetZoomBtn) {
                resetZoomBtn.addEventListener('click', function() {
                    trendsChart.resetZoom();
                });
            }
            
            // Add reset categories functionality
            const resetCategoriesBtn = document.getElementById('reset-categories-btn');
            if (resetCategoriesBtn) {
                resetCategoriesBtn.addEventListener('click', function() {
                    // Show all categories
                    trendsChart.data.datasets.forEach((dataset, index) => {
                        trendsChart.getDatasetMeta(index).hidden = false;
                    });
                    trendsChart.update();
                });
            }
        }
        
        async function fetchMonthlyTrends() {
            try {
                const response = await fetch('/api/monthly-trends');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                renderTrendsChart(data);
                return data;
            } catch (error) {
                console.error('Error fetching monthly trends data:', error);
                throw error;
            }
        }
        
        function renderPeltChart(data) {
            const ctx = document.getElementById('peltChart').getContext('2d');
            // Clean up any existing chart
            const existingChart = Chart.getChart(ctx.canvas);
            if (existingChart) {
                existingChart.destroy();
            }
            // If no data or error, show placeholder
            if (!data || data.error || !data.datasets || data.datasets.length === 0) {
                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: ['No data available'],
                        datasets: [{
                            data: [0],
                            borderColor: '#ccc',
                            borderDash: [5, 5]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        }
                    }
                });
                return;
            }
            // Store labels globally for x-axis sync
            window.peltLabels = data.labels;
            // Create the chart with improved options
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: data.datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    elements: {
                        line: {
                            tension: 0.3 // Add slight curve to lines
                        }
                    },
                    scales: {
                        x: {
                            type: 'category',
                            grid: {
                                color: 'rgba(0,0,0,0.05)',
                                display: true
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 12
                                }
                            },
                            ticks: {
                                maxTicksLimit: 8,
                                autoSkip: true,
                                maxRotation: 45,
                                minRotation: 45,
                                color: '#666',
                                font: {
                                    family: 'Inter'
                                }
                            }
                        },
                        y: {
                            grid: {
                                color: 'rgba(0,0,0,0.05)',
                                display: true
                            },
                            title: {
                                display: true,
                                text: 'Balance',
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 12
                                }
                            },
                            ticks: {
                                color: '#666',
                                font: {
                                    family: 'Inter'
                                },
                                callback: function(value) {
                                    return new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD',
                                        maximumFractionDigits: 0
                                    }).format(value);
                                }
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            titleFont: {
                                family: 'Inter'
                            },
                            bodyFont: {
                                family: 'Inter'
                            },
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    return `${context.dataset.label}: ${new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD'
                                    }).format(value)}`;
                                }
                            },
                            displayColors: true,
                            backgroundColor: 'rgba(0,0,0,0.7)'
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                font: {
                                    family: 'Inter'
                                },
                                color: '#666',
                                usePointStyle: true,
                                pointStyle: 'circle'
                            }
                        }
                    }
                }
            });
            // Add vertical lines for change points as short annotation lines centered on the data point
            if (data.changePoints && data.changePoints.length > 0) {
                if (!chart.options.plugins) chart.options.plugins = {};
                if (!chart.options.plugins.annotation) chart.options.plugins.annotation = { annotations: {} };
                // Find the y-value (balance) for each change point
                data.changePoints.forEach((date, idx) => {
                    const dateIndex = data.labels.indexOf(date);
                    if (dateIndex === -1) return;
                    // Use the first dataset (balance) for y-value
                    const yVal = data.datasets[0].data[dateIndex];
                    if (typeof yVal !== 'number') return;
                    // Draw a more noticeable, thicker, solid, and slightly longer line centered on yVal
                    const yOffset = Math.max(5, Math.abs(yVal) * 0.07); // 7% of value or at least 5 units
                    const annotationId = `cp_${idx}`;
                    const backgroundAnnotationId = `cp_bg_${idx}`;
                    // Use direction to set color
                    let color = 'rgba(0,0,0,0.85)';
                    let bgColor = 'rgba(0,0,0,0.1)';
                    if (data.changePointDirections && data.changePointDirections[idx]) {
                        if (data.changePointDirections[idx] === 'up') {
                            color = 'rgba(40, 167, 69, 0.8)';
                            bgColor = 'rgba(40, 167, 69, 0.15)';
                        } else {
                            color = 'rgba(220, 53, 69, 0.8)';
                            bgColor = 'rgba(220, 53, 69, 0.15)';
                        }
                    }
                    
                    // Add the main changepoint line (short, centered)
                    chart.options.plugins.annotation.annotations[annotationId] = {
                        type: 'line',
                        xMin: date,
                        xMax: date,
                        yMin: yVal - yOffset,
                        yMax: yVal + yOffset,
                        borderColor: color,
                        borderWidth: 6,
                        borderDash: [], // solid line
                        label: {
                            display: false
                        }
                    };
                    
                    // Add the background line (full height, transparent)
                    chart.options.plugins.annotation.annotations[backgroundAnnotationId] = {
                        type: 'line',
                        xMin: date,
                        xMax: date,
                        yMin: '0%',
                        yMax: '100%',
                        borderColor: bgColor,
                        borderWidth: 6,
                        borderDash: [], // solid line
                        label: {
                            display: false
                        }
                    };
                });
                chart.update();
            }
        }
        
        function renderRateOfChangeChart(rateData) {
            const ctx = document.getElementById('rateOfChangeChart').getContext('2d');
            // Clean up any existing chart
            const existingChart = Chart.getChart(ctx.canvas);
            if (existingChart) {
                existingChart.destroy();
            }
            // If no data, show placeholder
            if (!rateData || !rateData.data || rateData.data.length === 0) {
                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: ['No data available'],
                        datasets: [{
                            data: [0],
                            borderColor: '#ccc',
                            borderDash: [5, 5]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        }
                    }
                });
                return;
            }
            // Use the same x-axis labels as the PELT chart if available
            let labels = rateData.labels;
            if (window.peltLabels && Array.isArray(window.peltLabels) && window.peltLabels.length === rateData.data.length) {
                labels = window.peltLabels;
            }
            // Create datasets for positive and negative values
            const positiveData = rateData.data.map(val => val > 0 ? val : null);
            const negativeData = rateData.data.map(val => val < 0 ? val : null);
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Positive Rate of Change',
                            data: positiveData,
                            borderColor: 'rgba(40, 167, 69, 0.8)',
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: true
                        },
                        {
                            label: 'Negative Rate of Change',
                            data: negativeData,
                            borderColor: 'rgba(220, 53, 69, 0.8)',
                            backgroundColor: 'rgba(220, 53, 69, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'category',
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxTicksLimit: 8,
                                autoSkip: true,
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Monthly Savings Rate ($)'
                            },
                            grid: {
                                color: function(context) {
                                    if (context.tick.value === 0) {
                                        return 'rgba(0, 0, 0, 0.5)';
                                    }
                                    return 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    if (context.tick.value === 0) {
                                        return 2;
                                    }
                                    return 1;
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD',
                                        maximumFractionDigits: 0
                                    }).format(value);
                                }
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    if (value === null) return null;
                                    const sign = value >= 0 ? '+' : '';
                                    return `Rate of Change: ${sign}${new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD'
                                    }).format(value)}/week`;
                                }
                            }
                        },
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }
        
        function renderSpendingTrendsChart(data) {
            const ctx = document.getElementById('spendingTrendsChart').getContext('2d');
            
            // Clean up any existing chart
            const existingChart = Chart.getChart(ctx.canvas);
            if (existingChart) {
                existingChart.destroy();
            }
            
            // Hide loading spinner
            document.getElementById('spendingTrendsChartLoader').classList.add('hidden');
            
            // If no data or error, show placeholder
            if (!data || data.error || !data.datasets || data.datasets.length === 0) {
                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['No data available'],
                        datasets: [{
                            data: [0],
                            backgroundColor: '#ccc'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        }
                    }
                });
                return;
            }
            
            // Check if we have any actual data points
            const hasData = data.datasets.some(dataset => 
                dataset.data && dataset.data.some(value => value !== 0)
            );
            
            if (!hasData) {
                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['No data in selected range'],
                        datasets: [{
                            data: [0],
                            backgroundColor: '#ccc'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        }
                    }
                });
                return;
            }
            
            // Create the chart with stacked bars and net amount bars
            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.labels,
                    datasets: data.datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxTicksLimit: 12,
                                autoSkip: true,
                                maxRotation: 45,
                                minRotation: 45,
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 11
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time Period',
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 12
                                }
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            grid: {
                                color: 'rgba(0,0,0,0.05)',
                                display: true
                            },
                            title: {
                                display: true,
                                text: 'Amount',
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 12
                                }
                            },
                            ticks: {
                                color: '#666',
                                font: {
                                    family: 'Inter',
                                    size: 11
                                },
                                callback: function(value) {
                                    return new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD',
                                        maximumFractionDigits: 0
                                    }).format(value);
                                }
                            }
                        },

                    },
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.7)',
                            titleFont: {
                                family: 'Inter',
                                size: 12
                            },
                            bodyFont: {
                                family: 'Inter',
                                size: 12
                            },
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.raw || 0;
                                    const sign = value >= 0 ? '+' : '';
                                    return `${label}: ${sign}${new Intl.NumberFormat('en-US', {
                                        style: 'currency',
                                        currency: 'USD'
                                    }).format(value)}`;
                                }
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                font: {
                                    family: 'Inter',
                                    size: 12
                                },
                                color: '#666',
                                usePointStyle: true,
                                pointStyle: 'rect'
                            }
                        }
                    }
                }
            });
        }
        
        // Category management functions
        let selectedCategories = new Set(); // Track selected categories
        let allAvailableCategories = []; // Track all available categories
        
        function getSelectedCategories() {
            return Array.from(selectedCategories);
        }
        
        function renderCategoryLegend(categories) {
            const legendContainer = document.getElementById('category-legend');
            if (!legendContainer) return;
            
            // Update the list of all available categories
            allAvailableCategories = [...categories];
            
            // If this is the first time loading categories, initialize all as selected
            if (selectedCategories.size === 0) {
                categories.forEach(category => selectedCategories.add(category));
            }
            
            legendContainer.innerHTML = '';
            
            categories.forEach(category => {
                const isSelected = selectedCategories.has(category);
                const badge = document.createElement('span');
                badge.className = `badge ${isSelected ? 'bg-primary' : 'bg-secondary'} category-badge`;
                badge.style.cursor = 'pointer';
                badge.textContent = category;
                badge.onclick = () => toggleCategory(category, badge);
                legendContainer.appendChild(badge);
            });
        }
        
        function toggleCategory(category, badgeElement) {
            if (selectedCategories.has(category)) {
                selectedCategories.delete(category);
                badgeElement.className = 'badge bg-secondary category-badge';
            } else {
                selectedCategories.add(category);
                badgeElement.className = 'badge bg-primary category-badge';
            }
            
            // Refresh the chart with new category selection
            fetchSpendingTrends();
        }

        // Initialize milestone chart
        let milestoneChart = null;
        let milestones = [];

        // Global function to calculate balance from progress percentage
        const calculateBalanceFromProgress = (progressPercent, currentBalance) => {
            const nextMilestone = milestones.find(m => m > currentBalance) || milestones[milestones.length - 1];
            const previousMilestone = milestones.filter(m => m <= currentBalance).pop() || 0;
            const milestoneRange = nextMilestone - previousMilestone;
            return previousMilestone + (milestoneRange * progressPercent / 100);
        };

        // Global function to calculate time estimate
        const calculateTimeEstimate = (trend) => {
            const remainingAmount = nextMilestone - currentBalance;
            const weeksToMilestone = trend > 0 ? Math.ceil(remainingAmount / trend) : Infinity;
            
            // Convert weeks to months and years for display
            const totalMonths = Math.ceil(weeksToMilestone / 4.33); // Average weeks per month
            const years = Math.floor(totalMonths / 12);
            const months = totalMonths % 12;

            if (trend <= 0) {
                return 'Trend is negative';
            }
            if (totalMonths > 36) {
                return 'Over 3 years';
            }
            if (years === 0) {
                return `${months} month${months !== 1 ? 's' : ''}`;
            }
            if (months === 0) {
                return `${years} year${years !== 1 ? 's' : ''}`;
            }
            return `${years} year${years !== 1 ? 's' : ''} ${months} month${months !== 1 ? 's' : ''}`;
        };

        // Global function to update time estimate display
        const updateTimeEstimate = (trend, currentBalance) => {
            const timeEstimateElement = document.getElementById('time-estimate-value');
            const remainingAmountElement = document.getElementById('remaining-amount');
            
            // Get the current balance from the timeline marker position
            const timelineMarker = document.querySelector('.timeline-marker');
            let currentDraggedBalance = currentBalance;
            if (timelineMarker) {
                const markerLeft = parseFloat(timelineMarker.style.left) || 0;
                currentDraggedBalance = calculateBalanceFromProgress(markerLeft, currentBalance);
            }
            
            const nextMilestone = milestones.find(m => m > currentDraggedBalance) || milestones[milestones.length - 1];
            const remainingAmount = nextMilestone - currentDraggedBalance;
            
            if (timeEstimateElement) {
                // Calculate time estimate for the dragged balance
                const weeksToMilestone = trend > 0 ? Math.ceil(remainingAmount / trend) : Infinity;
                const totalMonths = Math.ceil(weeksToMilestone / 4.33);
                const years = Math.floor(totalMonths / 12);
                const months = totalMonths % 12;

                let timeEstimate;
                if (trend <= 0) {
                    timeEstimate = 'Trend is negative';
                } else if (totalMonths > 36) {
                    timeEstimate = 'Over 3 years';
                } else if (years === 0) {
                    timeEstimate = `${months} month${months !== 1 ? 's' : ''}`;
                } else if (months === 0) {
                    timeEstimate = `${years} year${years !== 1 ? 's' : ''}`;
                } else {
                    timeEstimate = `${years} year${years !== 1 ? 's' : ''} ${months} month${months !== 1 ? 's' : ''}`;
                }
                
                timeEstimateElement.textContent = timeEstimate;
            }
            if (remainingAmountElement) {
                remainingAmountElement.textContent = trend > 0 ? 
                    `Need ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(remainingAmount)} more` : '';
            }
        };

        function renderMilestoneChart(balanceData) {
            const ctx = document.getElementById('milestoneChart').getContext('2d');
            
            // Get the current balance from the data
            const currentBalance = balanceData && balanceData.datasets && balanceData.datasets[0] && balanceData.datasets[0].data 
                ? balanceData.datasets[0].data[balanceData.datasets[0].data.length - 1] 
                : 0;
            
            // Calculate next milestone
            const nextMilestone = milestones.find(m => m > currentBalance) || milestones[milestones.length - 1];
            const previousMilestone = milestones.filter(m => m <= currentBalance).pop() || 0;
            
            // Calculate progress percentage between current milestones
            const progress = ((currentBalance - previousMilestone) / (nextMilestone - previousMilestone)) * 100;
            
            // Function to calculate time estimate based on trend
            const calculateTimeEstimate = (trend) => {
                    const remainingAmount = nextMilestone - currentBalance;
                    const weeksToMilestone = trend > 0 ? Math.ceil(remainingAmount / trend) : Infinity;
                    
                    // Convert weeks to months and years for display
                    const totalMonths = Math.ceil(weeksToMilestone / 4.33); // Average weeks per month
                    const years = Math.floor(totalMonths / 12);
                    const months = totalMonths % 12;

                        if (trend <= 0) {
                            return 'Trend is negative';
                        }
                        if (totalMonths > 36) {
                            return 'Over 3 years';
                        }
                        if (years === 0) {
                            return `${months} month${months !== 1 ? 's' : ''}`;
                        }
                        if (months === 0) {
                            return `${years} year${years !== 1 ? 's' : ''}`;
                        }
                        return `${years} year${years !== 1 ? 's' : ''} ${months} month${months !== 1 ? 's' : ''}`;
                    };

            // Function to update the time estimate display
            const updateTimeEstimate = (trend, passedBalance) => {
                const timeEstimateElement = document.getElementById('time-estimate-value');
                const remainingAmountElement = document.getElementById('remaining-amount');
                
                // Get the current balance from the timeline marker position
                const timelineMarker = document.querySelector('.timeline-marker');
                let currentDraggedBalance = passedBalance || currentBalance;
                if (timelineMarker) {
                    const markerLeft = parseFloat(timelineMarker.style.left) || 0;
                    currentDraggedBalance = calculateBalanceFromProgress(markerLeft, currentBalance);
                }
                
                const nextMilestone = milestones.find(m => m > currentDraggedBalance) || milestones[milestones.length - 1];
                const remainingAmount = nextMilestone - currentDraggedBalance;
                
                if (timeEstimateElement) {
                    // Calculate time estimate for the dragged balance
                    const weeksToMilestone = trend > 0 ? Math.ceil(remainingAmount / trend) : Infinity;
                    const totalMonths = Math.ceil(weeksToMilestone / 4.33);
                    const years = Math.floor(totalMonths / 12);
                    const months = totalMonths % 12;

                    let timeEstimate;
                    if (trend <= 0) {
                        timeEstimate = 'Trend is negative';
                    } else if (totalMonths > 36) {
                        timeEstimate = 'Over 3 years';
                    } else if (years === 0) {
                        timeEstimate = `${months} month${months !== 1 ? 's' : ''}`;
                    } else if (months === 0) {
                        timeEstimate = `${years} year${years !== 1 ? 's' : ''}`;
                    } else {
                        timeEstimate = `${years} year${years !== 1 ? 's' : ''} ${months} month${months !== 1 ? 's' : ''}`;
                    }
                    
                    timeEstimateElement.textContent = timeEstimate;
                }
                if (remainingAmountElement) {
                    remainingAmountElement.textContent = trend > 0 ? 
                        `Need ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(remainingAmount)} more` : '';
                }
            };

            // Function to reset timeline to actual balance
            const resetToActualBalance = () => {
                const timelineMarker = document.querySelector('.timeline-marker');
                const progressBar = document.querySelector('.timeline-progress');
                
                if (timelineMarker && progressBar) {
                    // Calculate the original progress percentage
                    const originalProgress = ((currentBalance - previousMilestone) / (nextMilestone - previousMilestone)) * 100;
                    
                    // Reset marker and progress bar
                    timelineMarker.style.left = `${originalProgress}%`;
                    progressBar.style.width = `${originalProgress}%`;
                    
                    // Update milestone calculations
                    updateMilestoneCalculations(currentBalance);
                    
                    // Update time estimate with current rate
                    const rateInput = document.getElementById('weekly-rate-input');
                    const currentRate = rateInput ? parseFloat(rateInput.value) || 0 : 0;
                    updateTimeEstimate(currentRate, currentBalance);
                }
            };

            // Function to calculate balance from progress percentage
            const calculateBalanceFromProgress = (progressPercent) => {
                const nextMilestone = milestones.find(m => m > currentBalance) || milestones[milestones.length - 1];
                const previousMilestone = milestones.filter(m => m <= currentBalance).pop() || 0;
                const milestoneRange = nextMilestone - previousMilestone;
                return previousMilestone + (milestoneRange * progressPercent / 100);
            };

            // Function to handle timeline dragging
            const setupTimelineDragging = () => {
                const timelineTrack = document.querySelector('.timeline-track');
                const timelineMarker = document.querySelector('.timeline-marker');
                const progressBar = document.querySelector('.timeline-progress');
                
                if (!timelineTrack || !timelineMarker || !progressBar) return;
                
                let isDragging = false;
                let startX, startLeft;
                
                const startDrag = (e) => {
                    isDragging = true;
                    startX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
                    startLeft = parseFloat(timelineMarker.style.left) || 0;
                    
                    timelineMarker.style.cursor = 'grabbing';
                    timelineTrack.style.cursor = 'grabbing';
                    
                    // Add dragging class for visual feedback
                    timelineMarker.classList.add('dragging');
                };
                
                const doDrag = (e) => {
                    if (!isDragging) return;
                    
                    e.preventDefault();
                    const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
                    const deltaX = clientX - startX;
                    const timelineRect = timelineTrack.getBoundingClientRect();
                    const timelineWidth = timelineRect.width;
                    
                    // Calculate new position as percentage
                    const newLeftPercent = Math.max(0, Math.min(100, startLeft + (deltaX / timelineWidth) * 100));
                    
                    // Update marker position
                    timelineMarker.style.left = `${newLeftPercent}%`;
                    progressBar.style.width = `${newLeftPercent}%`;
                    
                    // Calculate and update balance
                    const newBalance = calculateBalanceFromProgress(newLeftPercent, currentBalance);
                    const currentBalanceValue = document.querySelector('.current-balance-value');
                    if (currentBalanceValue) {
                        currentBalanceValue.textContent = new Intl.NumberFormat('en-US', { 
                            style: 'currency', 
                            currency: 'USD', 
                            maximumFractionDigits: 0 
                        }).format(newBalance);
                    }
                    
                    // Update milestone calculations
                    updateMilestoneCalculations(newBalance);
                };
                
                const stopDrag = () => {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    timelineMarker.style.cursor = 'grab';
                    timelineTrack.style.cursor = 'grab';
                    timelineMarker.classList.remove('dragging');
                };
                
                // Mouse events
                timelineMarker.addEventListener('mousedown', startDrag);
                document.addEventListener('mousemove', doDrag);
                document.addEventListener('mouseup', stopDrag);
                
                // Touch events for mobile
                timelineMarker.addEventListener('touchstart', startDrag);
                document.addEventListener('touchmove', doDrag);
                document.addEventListener('touchend', stopDrag);
                
                // Click on timeline to jump to position
                timelineTrack.addEventListener('click', (e) => {
                    const rect = timelineTrack.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const clickPercent = (clickX / rect.width) * 100;
                    const clampedPercent = Math.max(0, Math.min(100, clickPercent));
                    
                    timelineMarker.style.left = `${clampedPercent}%`;
                    progressBar.style.width = `${clampedPercent}%`;
                    
                    const newBalance = calculateBalanceFromProgress(clampedPercent, currentBalance);
                    const currentBalanceValue = document.querySelector('.current-balance-value');
                    if (currentBalanceValue) {
                        currentBalanceValue.textContent = new Intl.NumberFormat('en-US', { 
                            style: 'currency', 
                            currency: 'USD', 
                            maximumFractionDigits: 0 
                        }).format(newBalance);
                    }
                    
                    updateMilestoneCalculations(newBalance);
                });
            };
            
            // Fetch goals to calculate target-based savings rate and get icons
            let targetBasedRate = 0;
            let nextGoalWithDate = null;
            let goalsMap = new Map(); // Map milestone amounts to goal objects

            fetch('/api/goals')
                .then(response => response.json())
                .then(goalsData => {
                    if (goalsData.success && goalsData.goals) {
                        // Create a map of milestone amounts to goals
                        goalsData.goals.forEach(goal => {
                            goalsMap.set(goal.amount, goal);
                        });

                        // Find the next goal with a target date
                        const goalsWithTargets = goalsData.goals
                            .filter(g => g.target_date && g.amount > currentBalance)
                            .sort((a, b) => a.amount - b.amount);

                        if (goalsWithTargets.length > 0) {
                            nextGoalWithDate = goalsWithTargets[0];
                            const targetDate = new Date(nextGoalWithDate.target_date);
                            const today = new Date();
                            const monthsRemaining = Math.max(1, (targetDate - today) / (1000 * 60 * 60 * 24 * 30.44));
                            const amountNeeded = nextGoalWithDate.amount - currentBalance;
                            targetBasedRate = amountNeeded / monthsRemaining;
                        }
                    }
                })
                .catch(err => console.error('Error fetching goals:', err));

            // Fetch PELT analysis data for trend calculation
            fetch('/api/pelt-analysis')
                .then(response => response.json())
                .then(peltData => {
                    // Get the most recent rate of change (PELT is weekly, convert to monthly)
                    let peltTrend = 0;
                    if (peltData && peltData.rateOfChange && peltData.rateOfChange.data) {
                        const rateData = peltData.rateOfChange.data;
                        // Get the last non-null value from the rate of change data
                        for (let i = rateData.length - 1; i >= 0; i--) {
                            if (rateData[i] !== null) {
                                peltTrend = rateData[i] * 4.33; // Convert weekly to monthly
                                break;
                            }
                        }
                    }

                    // Use target-based rate if available, otherwise use PELT (both are now monthly)
                    let defaultTrend = targetBasedRate > 0 ? targetBasedRate : peltTrend;

                    // Create the milestone visualization
                    const milestoneInfo = document.createElement('div');
                    milestoneInfo.className = 'milestone-timeline-container';
                    milestoneInfo.innerHTML = `
                        <style>
                            .milestone-timeline-container {
                                padding: 30px 20px;
                                font-family: 'Inter', sans-serif;
                            }
                            .timeline-track {
                                height: 8px;
                                background: #eef2f7;
                                border-radius: 4px;
                                position: relative;
                                margin: 40px 0;
                            }
                            .timeline-progress {
                                position: absolute;
                                left: 0;
                                top: 0;
                                height: 100%;
                                background: linear-gradient(90deg, #4285f4, #5c9fff);
                                border-radius: 4px;
                                transition: width 1s ease-in-out;
                            }
                            .timeline-marker {
                                width: 24px;
                                height: 24px;
                                background: white;
                                border: 3px solid #4285f4;
                                border-radius: 50%;
                                position: absolute;
                                top: 50%;
                                transform: translate(-50%, -50%);
                                transition: left 1s ease-in-out;
                                box-shadow: 0 2px 6px rgba(0,0,0,0.2);
                                cursor: grab;
                                user-select: none;
                                z-index: 20;
                            }
                            .timeline-marker:hover {
                                transform: translate(-50%, -50%) scale(1.1);
                                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            }
                            .timeline-marker.dragging {
                                cursor: grabbing;
                                transform: translate(-50%, -50%) scale(1.2);
                                box-shadow: 0 6px 20px rgba(0,0,0,0.4);
                                transition: none;
                            }
                            .timeline-track {
                                height: 8px;
                                background: #eef2f7;
                                border-radius: 4px;
                                position: relative;
                                margin: 40px 0;
                                cursor: pointer;
                            }
                            .timeline-track:hover {
                                background: #e2e8f0;
                            }
                            .milestone-marker {
                                position: absolute;
                                top: -30px;
                                transform: translateX(-50%);
                                text-align: center;
                            }
                            .milestone-marker::after {
                                content: '';
                                position: absolute;
                                bottom: -10px;
                                left: 50%;
                                transform: translateX(-50%);
                                width: 2px;
                                height: 8px;
                                background: #cbd5e1;
                            }
                            .milestone-value {
                                font-weight: 600;
                                color: #1a73e8;
                                font-size: 0.9rem;
                            }
                            .current-balance {
                                position: absolute;
                                top: 25px;
                                transform: translateX(-50%);
                                text-align: center;
                                background: white;
                                padding: 8px 16px;
                                border-radius: 20px;
                                box-shadow: 0 2px 12px rgba(0,0,0,0.1);
                                border: 1px solid #e1e8f0;
                            }
                            .current-balance-value {
                                font-weight: 700;
                                color: #1e293b;
                                font-size: 1.1rem;
                            }
                            .original-balance-indicator {
                                position: absolute;
                                top: -15px;
                                left: 50%;
                                transform: translateX(-50%);
                                width: 0;
                                height: 0;
                                border-left: 6px solid transparent;
                                border-right: 6px solid transparent;
                                border-bottom: 8px solid #ff6b6b;
                                z-index: 10;
                            }
                            .milestone-stats {
                                display: grid;
                                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                                gap: 20px;
                                margin-top: 60px;
                            }
                            .stat-card {
                                background: white;
                                padding: 20px;
                                border-radius: 12px;
                                box-shadow: 0 2px 12px rgba(0,0,0,0.08);
                                border: 1px solid #e1e8f0;
                            }
                            .stat-label {
                                color: #64748b;
                                font-size: 0.9rem;
                                margin-bottom: 8px;
                            }
                            .stat-value {
                                color: #1e293b;
                                font-weight: 600;
                                font-size: 1.1rem;
                            }
                            .trend-indicator {
                                display: inline-flex;
                                align-items: center;
                                padding: 4px 12px;
                                border-radius: 16px;
                                font-size: 0.9rem;
                                margin-left: 8px;
                            }
                            .trend-positive {
                                background: #dcfce7;
                                color: #166534;
                            }
                            .trend-negative {
                                background: #fee2e2;
                                color: #991b1b;
                            }
                            .rate-input-container {
                                display: flex;
                                align-items: center;
                                gap: 10px;
                                margin-top: 10px;
                            }
                            .rate-input {
                                width: 120px;
                                padding: 6px 12px;
                                border: 1px solid #d1d5db;
                                border-radius: 6px;
                                font-size: 0.9rem;
                                text-align: right;
                            }
                            .rate-input:focus {
                                outline: none;
                                border-color: #4285f4;
                                box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.1);
                            }
                            .rate-unit {
                                color: #64748b;
                                font-size: 0.9rem;
                            }
                            .reset-button {
                                background: none;
                                border: none;
                                color: #4285f4;
                                font-size: 0.8rem;
                                cursor: pointer;
                                text-decoration: underline;
                                padding: 0;
                                margin-left: 10px;
                            }
                            .reset-button:hover {
                                color: #1a73e8;
                            }
                            .balance-slider-container {
                                margin-top: 20px;
                                padding: 20px;
                                background: #f8f9fa;
                                border-radius: 12px;
                                border: 1px solid #e1e8f0;
                            }
                            .balance-slider-label {
                                display: flex;
                                justify-content: space-between;
                                align-items: center;
                                margin-bottom: 15px;
                            }
                            .balance-slider-value {
                                font-weight: 600;
                                color: #1e293b;
                                font-size: 1.1rem;
                            }
                            .balance-slider {
                                width: 100%;
                                height: 6px;
                                border-radius: 3px;
                                background: #e1e8f0;
                                outline: none;
                                -webkit-appearance: none;
                                appearance: none;
                            }
                            .balance-slider::-webkit-slider-thumb {
                                -webkit-appearance: none;
                                appearance: none;
                                width: 20px;
                                height: 20px;
                                border-radius: 50%;
                                background: #4285f4;
                                cursor: pointer;
                                box-shadow: 0 2px 6px rgba(66, 133, 244, 0.3);
                                transition: all 0.2s ease;
                            }
                            .balance-slider::-webkit-slider-thumb:hover {
                                transform: scale(1.1);
                                box-shadow: 0 4px 12px rgba(66, 133, 244, 0.4);
                            }
                            .balance-slider::-moz-range-thumb {
                                width: 20px;
                                height: 20px;
                                border-radius: 50%;
                                background: #4285f4;
                                cursor: pointer;
                                border: none;
                                box-shadow: 0 2px 6px rgba(66, 133, 244, 0.3);
                            }
                            .balance-slider::-moz-range-thumb:hover {
                                transform: scale(1.1);
                                box-shadow: 0 4px 12px rgba(66, 133, 244, 0.4);
                            }
                            .balance-slider-range {
                                display: flex;
                                justify-content: space-between;
                                margin-top: 10px;
                                font-size: 0.8rem;
                                color: #64748b;
                            }
                            .reset-balance-button {
                                background: none;
                                border: none;
                                color: #4285f4;
                                font-size: 0.8rem;
                                cursor: pointer;
                                text-decoration: underline;
                                padding: 0;
                                margin-top: 10px;
                            }
                            .reset-balance-button:hover {
                                color: #1a73e8;
                            }
                        </style>
                        <div class="timeline-track">
                            <div class="timeline-progress" style="width: ${progress}%"></div>
                            <div class="timeline-marker" style="left: ${progress}%">
                                <div class="current-balance">
                                    <div class="current-balance-value">
                                        ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(currentBalance)}
                                    </div>
                                </div>
                            </div>
                            <div class="original-balance-indicator" style="left: ${progress}%"></div>
                            <div class="milestone-marker" style="left: 0%">
                                <div class="milestone-value">
                                    ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(previousMilestone)}
                                </div>
                            </div>
                            <div class="milestone-marker" style="left: 100%">
                                <div class="milestone-value">
                                    ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(nextMilestone)}
                                </div>
                            </div>
                        </div>
                        <div class="milestone-stats">
                            <div class="stat-card">
                                <div class="stat-label">Progress to Next Milestone</div>
                                <div class="stat-value">${progress.toFixed(1)}%</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Monthly Savings Rate</div>
                                <div class="stat-value">
                                    <span id="trend-display">
                                        ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(defaultTrend)}
                                    </span>
                                    <span class="trend-indicator ${defaultTrend >= 0 ? 'trend-positive' : 'trend-negative'}">
                                        ${defaultTrend >= 0 ? '' : ''} per month
                                    </span>
                                </div>
                                <div class="rate-input-container">
                                    <input type="number" 
                                           id="weekly-rate-input" 
                                           class="rate-input" 
                                           value="${defaultTrend.toFixed(0)}" 
                                           step="100" 
                                           placeholder="Enter rate">
                                    <span class="rate-unit">$/month</span>
                                    <button class="reset-button" id="reset-rate-btn">Reset to PELT</button>
                                </div>
                                <div class="small text-muted mt-2">Based on PELT analysis</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Estimated Time to Next Milestone</div>
                                <div class="stat-value" id="time-estimate-value">
                                    ${calculateTimeEstimate(defaultTrend)}
                                </div>
                                <div class="small text-muted mt-2" id="remaining-amount">
                                    ${defaultTrend > 0 ? `Need ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(nextMilestone - currentBalance)} more` : ''}
                                </div>
                                <div id="projection-indicator" class="mt-2" style="display: none; padding: 10px; background: #e3f2fd; border-left: 3px solid #2196f3; border-radius: 4px;">
                                    <div style="color: #1976d2; font-weight: 500; font-size: 14px;">
                                        <i class="fas fa-chart-line"></i> <span id="projection-text"></span>
                                    </div>
                                </div>
                                <button class="reset-button" id="reset-balance-btn" style="margin-top: 10px;">Reset to Actual Balance</button>
                            </div>
                        </div>
                    `;
                    
                    // Remove any existing milestone info
                    const existingInfo = document.querySelector('#milestoneChart').parentNode.querySelector('.milestone-timeline-container');
                    if (existingInfo) {
                        existingInfo.remove();
                    }
                    
                    // Remove the canvas since we're not using Chart.js anymore
                    const canvas = document.getElementById('milestoneChart');
                    canvas.remove();
                    
                    // Add the new timeline visualization
                    document.getElementById('milestoneChartLoader').insertAdjacentElement('afterend', milestoneInfo);
                    
                    // Hide the loading spinner
                    document.getElementById('milestoneChartLoader').classList.add('hidden');

                    // Add event listeners for the interactive elements
                    const rateInput = document.getElementById('weekly-rate-input');
                    const resetButton = document.getElementById('reset-rate-btn');
                    const resetBalanceButton = document.getElementById('reset-balance-btn');
                    const trendDisplay = document.getElementById('trend-display');
                    const trendIndicator = trendDisplay.nextElementSibling;

                    if (rateInput) {
                        rateInput.addEventListener('input', function() {
                            const newRate = parseFloat(this.value) || 0;
                            // Get the balance at the marker's current position
                            const timelineMarker = document.querySelector('.timeline-marker');
                            let draggedBalance = currentBalance;
                            if (timelineMarker) {
                                const markerLeft = parseFloat(timelineMarker.style.left) || 0;
                                draggedBalance = calculateBalanceFromProgress(markerLeft, currentBalance);
                            }
                            // Update the display
                            trendDisplay.textContent = new Intl.NumberFormat('en-US', { 
                                style: 'currency', 
                                currency: 'USD', 
                                maximumFractionDigits: 0 
                            }).format(newRate);
                            // Update trend indicator
                            trendIndicator.className = `trend-indicator ${newRate >= 0 ? 'trend-positive' : 'trend-negative'}`;
                            trendIndicator.innerHTML = `${newRate >= 0 ? '' : ''} per month`;
                            // Update time estimate using dragged balance
                            updateTimeEstimate(newRate, draggedBalance);

                            // Show projection if rate is different from default
                            const projectionIndicator = document.getElementById('projection-indicator');
                            const projectionText = document.getElementById('projection-text');

                            if (projectionIndicator && projectionText && Math.abs(newRate - defaultTrend) > 1 && newRate > 0 && nextGoalWithDate) {
                                const targetDate = new Date(nextGoalWithDate.target_date);
                                const today = new Date();
                                const monthsToTarget = Math.max(1, (targetDate - today) / (1000 * 60 * 60 * 24 * 30.44));
                                const projectedAmount = draggedBalance + (newRate * monthsToTarget);
                                const goalAmount = nextGoalWithDate.amount;

                                const formattedAmount = new Intl.NumberFormat('en-US', {
                                    style: 'currency',
                                    currency: 'USD',
                                    maximumFractionDigits: 0
                                }).format(projectedAmount);

                                const formattedDate = targetDate.toLocaleDateString('en-US', {
                                    month: 'short',
                                    day: 'numeric',
                                    year: 'numeric'
                                });

                                if (projectedAmount >= goalAmount) {
                                    projectionText.innerHTML = `At this rate, you'll reach <strong>${formattedAmount}</strong> by ${formattedDate} (${nextGoalWithDate.name} goal: ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(goalAmount)}) `;
                                    projectionIndicator.style.background = '#e8f5e9';
                                    projectionIndicator.style.borderColor = '#4caf50';
                                    projectionText.style.color = '#2e7d32';
                                } else {
                                    const shortfall = goalAmount - projectedAmount;
                                    projectionText.innerHTML = `At this rate, you'll reach <strong>${formattedAmount}</strong> by ${formattedDate} (${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(shortfall)} short of ${nextGoalWithDate.name})`;
                                    projectionIndicator.style.background = '#fff3e0';
                                    projectionIndicator.style.borderColor = '#ff9800';
                                    projectionText.style.color = '#e65100';
                                }

                                projectionIndicator.style.display = 'block';
                            } else if (projectionIndicator) {
                                projectionIndicator.style.display = 'none';
                            }
                        });
                    }

                    if (resetButton) {
                        resetButton.addEventListener('click', function() {
                            rateInput.value = defaultTrend.toFixed(0);
                            rateInput.dispatchEvent(new Event('input'));
                        });
                    }

                    if (resetBalanceButton) {
                        resetBalanceButton.addEventListener('click', function() {
                            resetToActualBalance();
                        });
                    }

                    // Setup timeline dragging
                    setupTimelineDragging();
                })
                .catch(error => {
                    console.error('Error fetching PELT analysis:', error);
                    // Fallback to simple trend calculation if PELT analysis fails
                    let defaultTrend = 0;
                    if (balanceData && balanceData.datasets && balanceData.datasets[0]) {
                        const data = balanceData.datasets[0].data;
                        if (data.length >= 2) {
                            const numMonths = Math.min(3, data.length - 1);
                            const recentChange = data[data.length - 1] - data[data.length - 1 - numMonths];
                            defaultTrend = recentChange / numMonths;
                        }
                    }
                    
                    // Create the milestone visualization with fallback trend
                    const milestoneInfo = document.createElement('div');
                    milestoneInfo.className = 'milestone-timeline-container';
                    milestoneInfo.innerHTML = `
                        <style>
                            .milestone-timeline-container {
                                padding: 30px 20px;
                                font-family: 'Inter', sans-serif;
                            }
                            .timeline-track {
                                height: 8px;
                                background: #eef2f7;
                                border-radius: 4px;
                                position: relative;
                                margin: 40px 0;
                            }
                            .timeline-progress {
                                position: absolute;
                                left: 0;
                                top: 0;
                                height: 100%;
                                background: linear-gradient(90deg, #4285f4, #5c9fff);
                                border-radius: 4px;
                                transition: width 1s ease-in-out;
                            }
                            .timeline-marker {
                                width: 24px;
                                height: 24px;
                                background: white;
                                border: 3px solid #4285f4;
                                border-radius: 50%;
                                position: absolute;
                                top: 50%;
                                transform: translate(-50%, -50%);
                                transition: left 1s ease-in-out;
                                box-shadow: 0 2px 6px rgba(0,0,0,0.2);
                                cursor: grab;
                                user-select: none;
                                z-index: 20;
                            }
                            .timeline-marker:hover {
                                transform: translate(-50%, -50%) scale(1.1);
                                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            }
                            .timeline-marker.dragging {
                                cursor: grabbing;
                                transform: translate(-50%, -50%) scale(1.2);
                                box-shadow: 0 6px 20px rgba(0,0,0,0.4);
                                transition: none;
                            }
                            .timeline-track {
                                height: 8px;
                                background: #eef2f7;
                                border-radius: 4px;
                                position: relative;
                                margin: 40px 0;
                                cursor: pointer;
                            }
                            .timeline-track:hover {
                                background: #e2e8f0;
                            }
                            .milestone-marker {
                                position: absolute;
                                top: -30px;
                                transform: translateX(-50%);
                                text-align: center;
                            }
                            .milestone-marker::after {
                                content: '';
                                position: absolute;
                                bottom: -10px;
                                left: 50%;
                                transform: translateX(-50%);
                                width: 2px;
                                height: 8px;
                                background: #cbd5e1;
                            }
                            .milestone-value {
                                font-weight: 600;
                                color: #1a73e8;
                                font-size: 0.9rem;
                            }
                            .current-balance {
                                position: absolute;
                                top: 25px;
                                transform: translateX(-50%);
                                text-align: center;
                                background: white;
                                padding: 8px 16px;
                                border-radius: 20px;
                                box-shadow: 0 2px 12px rgba(0,0,0,0.1);
                                border: 1px solid #e1e8f0;
                            }
                            .current-balance-value {
                                font-weight: 700;
                                color: #1e293b;
                                font-size: 1.1rem;
                            }
                            .milestone-stats {
                                display: grid;
                                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                                gap: 20px;
                                margin-top: 60px;
                            }
                            .stat-card {
                                background: white;
                                padding: 20px;
                                border-radius: 12px;
                                box-shadow: 0 2px 12px rgba(0,0,0,0.08);
                                border: 1px solid #e1e8f0;
                            }
                            .stat-label {
                                color: #64748b;
                                font-size: 0.9rem;
                                margin-bottom: 8px;
                            }
                            .stat-value {
                                color: #1e293b;
                                font-weight: 600;
                                font-size: 1.1rem;
                            }
                            .trend-indicator {
                                display: inline-flex;
                                align-items: center;
                                padding: 4px 12px;
                                border-radius: 16px;
                                font-size: 0.9rem;
                                margin-left: 8px;
                            }
                            .trend-positive {
                                background: #dcfce7;
                                color: #166534;
                            }
                            .trend-negative {
                                background: #fee2e2;
                                color: #991b1b;
                            }
                            .rate-input-container {
                                display: flex;
                                align-items: center;
                                gap: 10px;
                                margin-top: 10px;
                            }
                            .rate-input {
                                width: 120px;
                                padding: 6px 12px;
                                border: 1px solid #d1d5db;
                                border-radius: 6px;
                                font-size: 0.9rem;
                                text-align: right;
                            }
                            .rate-input:focus {
                                outline: none;
                                border-color: #4285f4;
                                box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.1);
                            }
                            .rate-unit {
                                color: #64748b;
                                font-size: 0.9rem;
                            }
                            .reset-button {
                                background: none;
                                border: none;
                                color: #4285f4;
                                font-size: 0.8rem;
                                cursor: pointer;
                                text-decoration: underline;
                                padding: 0;
                                margin-left: 10px;
                            }
                            .reset-button:hover {
                                color: #1a73e8;
                            }
                            .balance-slider-container {
                                margin-top: 20px;
                                padding: 20px;
                                background: #f8f9fa;
                                border-radius: 12px;
                                border: 1px solid #e1e8f0;
                            }
                            .balance-slider-label {
                                display: flex;
                                justify-content: space-between;
                                align-items: center;
                                margin-bottom: 15px;
                            }
                            .balance-slider-value {
                                font-weight: 600;
                                color: #1e293b;
                                font-size: 1.1rem;
                            }
                            .balance-slider {
                                width: 100%;
                                height: 6px;
                                border-radius: 3px;
                                background: #e1e8f0;
                                outline: none;
                                -webkit-appearance: none;
                                appearance: none;
                            }
                            .balance-slider::-webkit-slider-thumb {
                                -webkit-appearance: none;
                                appearance: none;
                                width: 20px;
                                height: 20px;
                                border-radius: 50%;
                                background: #4285f4;
                                cursor: pointer;
                                box-shadow: 0 2px 6px rgba(66, 133, 244, 0.3);
                                transition: all 0.2s ease;
                            }
                            .balance-slider::-webkit-slider-thumb:hover {
                                transform: scale(1.1);
                                box-shadow: 0 4px 12px rgba(66, 133, 244, 0.4);
                            }
                            .balance-slider::-moz-range-thumb {
                                width: 20px;
                                height: 20px;
                                border-radius: 50%;
                                background: #4285f4;
                                cursor: pointer;
                                border: none;
                                box-shadow: 0 2px 6px rgba(66, 133, 244, 0.3);
                            }
                            .balance-slider::-moz-range-thumb:hover {
                                transform: scale(1.1);
                                box-shadow: 0 4px 12px rgba(66, 133, 244, 0.4);
                            }
                            .balance-slider-range {
                                display: flex;
                                justify-content: space-between;
                                margin-top: 10px;
                                font-size: 0.8rem;
                                color: #64748b;
                            }
                            .reset-balance-button {
                                background: none;
                                border: none;
                                color: #4285f4;
                                font-size: 0.8rem;
                                cursor: pointer;
                                text-decoration: underline;
                                padding: 0;
                                margin-top: 10px;
                            }
                            .reset-balance-button:hover {
                                color: #1a73e8;
                            }
                        </style>
                        <div class="timeline-track">
                            <div class="timeline-progress" style="width: ${progress}%"></div>
                            <div class="timeline-marker" style="left: ${progress}%">
                                <div class="current-balance">
                                    <div class="current-balance-value">
                                        ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(currentBalance)}
                                    </div>
                                </div>
                            </div>
                            <div class="original-balance-indicator" style="left: ${progress}%"></div>
                            <div class="milestone-marker" style="left: 0%">
                                <div class="milestone-value">
                                    ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(previousMilestone)}
                                </div>
                            </div>
                            <div class="milestone-marker" style="left: 100%">
                                <div class="milestone-value">
                                    ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(nextMilestone)}
                                </div>
                            </div>
                        </div>
                        <div class="balance-slider-container">
                            <div class="balance-slider-label">
                                <span class="stat-label">Simulate Different Balance</span>
                                <span class="balance-slider-value" id="balance-slider-value">
                                    ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(currentBalance)}
                                </span>
                            </div>
                            <input type="range" 
                                   id="balance-slider" 
                                   class="balance-slider" 
                                   min="0" 
                                   max="1000000" 
                                   step="1000" 
                                   value="${currentBalance}">
                            <div class="balance-slider-range">
                                <span>$0</span>
                                <span>$1,000,000</span>
                            </div>
                            <button class="reset-balance-button" id="reset-balance-btn">Reset to Actual Balance</button>
                        </div>
                        <div class="milestone-stats">
                            <div class="stat-card">
                                <div class="stat-label">Progress to Next Milestone</div>
                                <div class="stat-value">${progress.toFixed(1)}%</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Monthly Savings Rate</div>
                                <div class="stat-value">
                                    <span id="trend-display">
                                        ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(defaultTrend)}
                                    </span>
                                    <span class="trend-indicator ${defaultTrend >= 0 ? 'trend-positive' : 'trend-negative'}">
                                        ${defaultTrend >= 0 ? '' : ''} per month
                                    </span>
                                </div>
                                <div class="rate-input-container">
                                    <input type="number" 
                                           id="weekly-rate-input" 
                                           class="rate-input" 
                                           value="${defaultTrend.toFixed(0)}" 
                                           step="100" 
                                           placeholder="Enter rate">
                                    <span class="rate-unit">$/month</span>
                                    <button class="reset-button" id="reset-rate-btn">Reset to PELT</button>
                                </div>
                                <div class="small text-muted mt-2">Based on PELT analysis</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Estimated Time to Next Milestone</div>
                                <div class="stat-value" id="time-estimate-value">
                                    ${calculateTimeEstimate(defaultTrend)}
                                </div>
                                <div class="small text-muted mt-2" id="remaining-amount">
                                    ${defaultTrend > 0 ? `Need ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(nextMilestone - currentBalance)} more` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // Remove any existing milestone info
                    const existingInfo = document.querySelector('#milestoneChart').parentNode.querySelector('.milestone-timeline-container');
                    if (existingInfo) {
                        existingInfo.remove();
                    }
                    
                    // Remove the canvas since we're not using Chart.js anymore
                    const canvas = document.getElementById('milestoneChart');
                    canvas.remove();
                    
                    // Add the new timeline visualization
                    document.getElementById('milestoneChartLoader').insertAdjacentElement('afterend', milestoneInfo);
                    
                    // Hide the loading spinner
                    document.getElementById('milestoneChartLoader').classList.add('hidden');

                    // Add event listeners for the interactive elements
                    const rateInput = document.getElementById('weekly-rate-input');
                    const resetButton = document.getElementById('reset-rate-btn');
                    const resetBalanceButton = document.getElementById('reset-balance-btn');
                    const trendDisplay = document.getElementById('trend-display');
                    const trendIndicator = trendDisplay.nextElementSibling;

                    if (rateInput) {
                        rateInput.addEventListener('input', function() {
                            const newRate = parseFloat(this.value) || 0;
                            // Get the balance at the marker's current position
                            const timelineMarker = document.querySelector('.timeline-marker');
                            let draggedBalance = currentBalance;
                            if (timelineMarker) {
                                const markerLeft = parseFloat(timelineMarker.style.left) || 0;
                                draggedBalance = calculateBalanceFromProgress(markerLeft, currentBalance);
                            }
                            // Update the display
                            trendDisplay.textContent = new Intl.NumberFormat('en-US', { 
                                style: 'currency', 
                                currency: 'USD', 
                                maximumFractionDigits: 0 
                            }).format(newRate);
                            // Update trend indicator
                            trendIndicator.className = `trend-indicator ${newRate >= 0 ? 'trend-positive' : 'trend-negative'}`;
                            trendIndicator.innerHTML = `${newRate >= 0 ? '' : ''} per month`;
                            // Update time estimate using dragged balance
                            updateTimeEstimate(newRate, draggedBalance);

                            // Show projection if rate is different from default
                            const projectionIndicator = document.getElementById('projection-indicator');
                            const projectionText = document.getElementById('projection-text');

                            if (projectionIndicator && projectionText && Math.abs(newRate - defaultTrend) > 1 && newRate > 0 && nextGoalWithDate) {
                                const targetDate = new Date(nextGoalWithDate.target_date);
                                const today = new Date();
                                const monthsToTarget = Math.max(1, (targetDate - today) / (1000 * 60 * 60 * 24 * 30.44));
                                const projectedAmount = draggedBalance + (newRate * monthsToTarget);
                                const goalAmount = nextGoalWithDate.amount;

                                const formattedAmount = new Intl.NumberFormat('en-US', {
                                    style: 'currency',
                                    currency: 'USD',
                                    maximumFractionDigits: 0
                                }).format(projectedAmount);

                                const formattedDate = targetDate.toLocaleDateString('en-US', {
                                    month: 'short',
                                    day: 'numeric',
                                    year: 'numeric'
                                });

                                if (projectedAmount >= goalAmount) {
                                    projectionText.innerHTML = `At this rate, you'll reach <strong>${formattedAmount}</strong> by ${formattedDate} (${nextGoalWithDate.name} goal: ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(goalAmount)}) `;
                                    projectionIndicator.style.background = '#e8f5e9';
                                    projectionIndicator.style.borderColor = '#4caf50';
                                    projectionText.style.color = '#2e7d32';
                                } else {
                                    const shortfall = goalAmount - projectedAmount;
                                    projectionText.innerHTML = `At this rate, you'll reach <strong>${formattedAmount}</strong> by ${formattedDate} (${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(shortfall)} short of ${nextGoalWithDate.name})`;
                                    projectionIndicator.style.background = '#fff3e0';
                                    projectionIndicator.style.borderColor = '#ff9800';
                                    projectionText.style.color = '#e65100';
                                }

                                projectionIndicator.style.display = 'block';
                            } else if (projectionIndicator) {
                                projectionIndicator.style.display = 'none';
                            }
                        });
                    }

                    if (resetButton) {
                        resetButton.addEventListener('click', function() {
                            rateInput.value = defaultTrend.toFixed(0);
                            rateInput.dispatchEvent(new Event('input'));
                        });
                    }

                    if (resetBalanceButton) {
                        resetBalanceButton.addEventListener('click', function() {
                            resetToActualBalance();
                        });
                    }

                    // Setup timeline dragging
                    setupTimelineDragging();
                });
        }

        // Add milestone chart initialization to the balance data fetch
        async function fetchBalanceData() {
            try {
                // First, load milestones from API
                const milestonesResponse = await fetch('/api/goals/milestones');
                if (milestonesResponse.ok) {
                    const milestonesData = await milestonesResponse.json();
                    if (milestonesData.success) {
                        milestones.length = 0;
                        milestones.push(...milestonesData.milestones);
                    }
                }

                // Then fetch balance data
                const response = await fetch('/api/balance-chart');
                if (!response.ok) {
                    throw new Error('Failed to fetch balance data');
                }
                const data = await response.json();

                if (!data || !data.datasets || !data.datasets[0] || !data.datasets[0].data) {
                    throw new Error('Invalid balance data format');
                }

                // Extract the last balance value from the datasets
                const lastDataset = data.datasets[0];
                const lastBalance = lastDataset.data[lastDataset.data.length - 1] || 0;

                // Create a simplified data object for the milestone chart
                const milestoneData = {
                    datasets: [{
                        data: [lastBalance],
                        backgroundColor: ['#4CAF50'],
                        borderColor: ['#388E3C'],
                        borderWidth: 1
                    }]
                };

                // Render both charts
                renderBalanceChart(data);
                renderMilestoneChart(milestoneData);
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('balanceChart').innerHTML = `<div class="alert alert-danger">Error loading data: ${error.message}</div>`;
                document.getElementById('milestoneChart').innerHTML = `<div class="alert alert-danger">Error loading data: ${error.message}</div>`;
            }
        }

        // Category Management Functions
        async function loadCategoryTable() {
            const container = document.getElementById('categoryTableContainer');
            if (!container) return;
            try {
                const response = await fetch('/api/categories/details');
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                if (!data.categories) {
                    throw new Error('No categories data received');
                }

                // Create table structure
                let tableHtml = `
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Category Name</th>
                                <th>Keywords</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                // Add each category to the table
                for (const [name, details] of Object.entries(data.categories)) {
                    const keywords = details.patterns ? details.patterns.join(', ') : '';
                    tableHtml += `
                        <tr>
                            <td>${name}</td>
                            <td>${keywords}</td>
                            <td>
                                <button class="btn btn-sm btn-primary edit-category" data-category="${name}">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn btn-sm btn-danger delete-category" data-category="${name}">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </td>
                        </tr>
                    `;
                }

                tableHtml += `
                        </tbody>
                    </table>
                `;

                container.innerHTML = tableHtml;

                // Add event listeners for edit and delete buttons
                container.querySelectorAll('.edit-category').forEach(button => {
                    button.addEventListener('click', () => {
                        const category = button.dataset.category;
                        const details = data.categories[category];
                        document.getElementById('editCategoryId').value = category;
                        document.getElementById('editCategoryName').value = category;
                        document.getElementById('editCategoryKeywords').value = details.patterns ? details.patterns.join(', ') : '';
                        $('#editCategoryModal').modal('show');
                    });
                });

                container.querySelectorAll('.delete-category').forEach(button => {
                    button.addEventListener('click', async () => {
                        const category = button.dataset.category;
                        if (confirm(`Are you sure you want to delete the category "${category}"?`)) {
                            try {
                                const response = await fetch(`/api/categories/${encodeURIComponent(category)}`, {
                                    method: 'DELETE'
                                });
                                if (!response.ok) {
                                    const errorData = await response.json();
                                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                                }
                                await loadCategoryTable();
                                await loadQuickCategorySelect();
                            } catch (error) {
                                console.error('Error deleting category:', error);
                                alert(`Error deleting category: ${error.message}`);
                            }
                        }
                    });
                });

            } catch (error) {
                console.error('Error loading categories:', error);
                container.innerHTML = `<div class="alert alert-danger">Error loading categories: ${error.message}</div>`;
            }
        }
        
        loadCategoryTable();

        async function openEditCategoryModal(category) {
            try {
                const response = await fetch(`/api/categories/${encodeURIComponent(category)}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch category details');
                }
                const data = await response.json();
                
                document.getElementById('editCategoryId').value = category;
                document.getElementById('editCategoryName').value = category;
                document.getElementById('editCategoryPatterns').value = 
                    data.patterns.map(p => p.terms.join(' ')).join('\n');
                
                const modal = new bootstrap.Modal(document.getElementById('editCategoryModal'));
                modal.show();
            } catch (error) {
                console.error('Error loading category details:', error);
                alert('Error loading category details');
            }
        }

        // Load category colors from the server
        const categoryColors = JSON.parse('{{ categoryColors|tojson|safe }}');

        // Utility function to get category color
        function getCategoryColor(category) {
            return categoryColors[category] || '#607D8B';
        }

        // Utility function to convert hex to rgba
        function hexToRgba(hex, alpha = 0.85) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r},${g},${b},${alpha})`;
        }

        // Update chart colors based on category
        function updateChartColors(chart, data) {
            if (data.datasets && data.datasets.length > 0) {
                data.datasets.forEach(dataset => {
                    const category = dataset.label;
                    const color = getCategoryColor(category);
                    dataset.borderColor = color;
                    dataset.backgroundColor = hexToRgba(color);
                    dataset.pointHoverBackgroundColor = color;
                    dataset.pointHoverBorderColor = 'white';
                });
            }
        }

        // Function to update milestone calculations based on new balance
        const updateMilestoneCalculations = (newBalance) => {
            const newNextMilestone = milestones.find(m => m > newBalance) || milestones[milestones.length - 1];
            const newPreviousMilestone = milestones.filter(m => m <= newBalance).pop() || 0;
            const newProgress = ((newBalance - newPreviousMilestone) / (newNextMilestone - newPreviousMilestone)) * 100;
            
            // Update progress bar
            const progressBar = document.querySelector('.timeline-progress');
            if (progressBar) {
                progressBar.style.width = `${newProgress}%`;
            }
            
            // Update current balance marker position
            const currentBalanceMarker = document.querySelector('.timeline-marker');
            if (currentBalanceMarker) {
                currentBalanceMarker.style.left = `${newProgress}%`;
            }
            
            // Update current balance display
            const currentBalanceValue = document.querySelector('.current-balance-value');
            if (currentBalanceValue) {
                currentBalanceValue.textContent = new Intl.NumberFormat('en-US', { 
                    style: 'currency', 
                    currency: 'USD', 
                    maximumFractionDigits: 0 
                }).format(newBalance);
            }
            
            // Update milestone values
            const milestoneMarkers = document.querySelectorAll('.milestone-marker');
            if (milestoneMarkers.length >= 2) {
                const previousMilestoneValue = milestoneMarkers[0].querySelector('.milestone-value');
                const nextMilestoneValue = milestoneMarkers[1].querySelector('.milestone-value');
                
                if (previousMilestoneValue) {
                    previousMilestoneValue.textContent = new Intl.NumberFormat('en-US', { 
                        style: 'currency', 
                        currency: 'USD', 
                        maximumFractionDigits: 0 
                    }).format(newPreviousMilestone);
                }
                
                if (nextMilestoneValue) {
                    nextMilestoneValue.textContent = new Intl.NumberFormat('en-US', { 
                        style: 'currency', 
                        currency: 'USD', 
                        maximumFractionDigits: 0 
                    }).format(newNextMilestone);
                }
            }
            
            // Update progress percentage
            const progressValue = document.querySelector('.stat-card:first-child .stat-value');
            if (progressValue) {
                progressValue.textContent = `${newProgress.toFixed(1)}%`;
            }
            
            // Update time estimate with current rate
            const rateInput = document.getElementById('weekly-rate-input');
            const currentRate = rateInput ? parseFloat(rateInput.value) || 0 : 0;
            updateTimeEstimate(currentRate, newBalance);
        };

        // Goals Management
        let currentGoals = [];
        let hasCustomGoals = false;

        // Fetch goals from API
        async function fetchGoals() {
            try {
                const response = await fetch('/api/goals');
                const data = await response.json();
                if (data.success) {
                    currentGoals = data.goals;
                    hasCustomGoals = data.has_custom_goals;
                    return data.goals;
                }
                return [];
            } catch (error) {
                console.error('Error fetching goals:', error);
                return [];
            }
        }

        // Open goals modal
        async function openGoalsModal() {
            await fetchGoals();
            renderGoalsList();
            const modal = new bootstrap.Modal(document.getElementById('goalsModal'));
            modal.show();
        }

        // Render goals list in modal
        function renderGoalsList() {
            const goalsList = document.getElementById('goalsList');
            const goalsType = document.getElementById('goalsType');

            console.log('Rendering goals list:', {
                hasCustomGoals: hasCustomGoals,
                goalsCount: currentGoals.length,
                goals: currentGoals
            });

            // Count predefined vs custom goals
            const predefinedCount = currentGoals.filter(g => g.is_predefined).length;
            const customCount = currentGoals.length - predefinedCount;

            let badgeHTML = '';
            if (predefinedCount > 0 && customCount > 0) {
                badgeHTML = `<span class="badge bg-info">${predefinedCount} Predefined</span> <span class="badge bg-success">${customCount} Custom</span>`;
            } else if (customCount > 0) {
                badgeHTML = `<span class="badge bg-success">${customCount} Custom</span>`;
            } else {
                badgeHTML = `<span class="badge bg-info">${predefinedCount} Predefined</span>`;
            }
            goalsType.innerHTML = badgeHTML;

            goalsList.innerHTML = currentGoals.map((goal, index) => {
                // Calculate monthly savings needed
                let monthlySavings = '';
                if (goal.target_date) {
                    const targetDate = new Date(goal.target_date);
                    const today = new Date();
                    const monthsRemaining = Math.max(0, Math.ceil((targetDate - today) / (1000 * 60 * 60 * 24 * 30.44)));

                    if (monthsRemaining > 0) {
                        const monthlyAmount = goal.amount / monthsRemaining;
                        monthlySavings = `
                            <div class="text-muted small mt-1">
                                <i class="fas fa-calendar"></i> Target: ${targetDate.toLocaleDateString()}
                                <br>
                                <i class="fas fa-piggy-bank"></i> Save ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(monthlyAmount)}/month (${monthsRemaining} months)
                            </div>
                        `;
                    } else {
                        monthlySavings = `
                            <div class="text-danger small mt-1">
                                <i class="fas fa-exclamation-triangle"></i> Target date has passed!
                            </div>
                        `;
                    }
                }

                const icon = goal.icon || 'piggy-bank';

                return `
                    <div class="list-group-item d-flex justify-content-between align-items-start">
                        <div class="goal-icon-display">
                            <i class="fas fa-${icon}"></i>
                        </div>
                        <div class="flex-grow-1">
                            <div>
                                <strong>${goal.name}</strong>
                                <span class="text-muted ms-2">
                                    ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(goal.amount)}
                                </span>
                            </div>
                            ${monthlySavings}
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-sm btn-outline-primary" onclick="editGoalById('${goal.id}')">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="btn btn-sm btn-outline-danger" onclick="deleteGoal('${goal.id}')">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Add new goal
        async function addGoal() {
            const nameInput = document.getElementById('goalName');
            const amountInput = document.getElementById('goalAmount');
            const targetDateInput = document.getElementById('goalTargetDate');
            const iconInput = document.getElementById('goalIcon');
            const errorDiv = document.getElementById('goalError');

            const name = nameInput.value.trim();
            const amount = parseFloat(amountInput.value);
            const targetDate = targetDateInput.value;
            const icon = iconInput.value;

            // Validate inputs
            if (!name) {
                errorDiv.textContent = 'Please enter a goal name';
                errorDiv.style.display = 'block';
                return;
            }

            if (isNaN(amount) || amount <= 0) {
                errorDiv.textContent = 'Please enter a valid amount greater than 0';
                errorDiv.style.display = 'block';
                return;
            }

            // Validate target date if provided
            if (targetDate) {
                const target = new Date(targetDate);
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                if (target < today) {
                    errorDiv.textContent = 'Target date must be in the future';
                    errorDiv.style.display = 'block';
                    return;
                }
            }

            try {
                const goalData = { name, amount, icon };
                if (targetDate) {
                    goalData.target_date = targetDate;
                }

                const response = await fetch('/api/goals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(goalData)
                });

                const data = await response.json();
                if (data.success) {
                    // Clear inputs
                    nameInput.value = '';
                    amountInput.value = '';
                    targetDateInput.value = '';
                    errorDiv.style.display = 'none';

                    // Refresh goals list
                    await fetchGoals();
                    renderGoalsList();

                    // Reload milestone chart with new goals
                    await reloadMilestones();
                } else {
                    errorDiv.textContent = data.error || 'Failed to add goal';
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('Error adding goal:', error);
                errorDiv.textContent = 'Error adding goal';
                errorDiv.style.display = 'block';
            }
        }

        // Delete goal
        async function deleteGoal(goalId) {
            if (!confirm('Are you sure you want to delete this goal?')) {
                return;
            }

            try {
                const response = await fetch(`/api/goals/${goalId}`, {
                    method: 'DELETE'
                });

                const data = await response.json();
                if (data.success) {
                    // Refresh goals list
                    await fetchGoals();
                    renderGoalsList();

                    // Reload milestone chart with new goals
                    await reloadMilestones();
                } else {
                    alert(data.error || 'Failed to delete goal');
                }
            } catch (error) {
                console.error('Error deleting goal:', error);
                alert('Error deleting goal');
            }
        }

        // Reload milestones from API
        async function reloadMilestones() {
            try {
                const response = await fetch('/api/goals/milestones');
                const data = await response.json();
                if (data.success) {
                    // Update the global milestones array
                    milestones.length = 0;
                    milestones.push(...data.milestones);

                    // Re-render the milestone chart
                    const balanceResponse = await fetch('/api/balance-chart');
                    const balanceData = await balanceResponse.json();
                    renderMilestoneChart(balanceData);
                }
            } catch (error) {
                console.error('Error reloading milestones:', error);
            }
        }

        // Edit goal
        let editingGoal = null;

        function editGoalById(goalId) {
            // Find the goal in currentGoals array
            const goal = currentGoals.find(g => g.id === goalId);
            if (!goal) {
                console.error('Goal not found:', goalId);
                return;
            }
            editGoal(goal);
        }

        function editGoal(goal) {
            editingGoal = goal;

            // Populate the edit form
            document.getElementById('editGoalName').value = goal.name;
            document.getElementById('editGoalAmount').value = goal.amount;

            // Format date for input (HTML date input expects YYYY-MM-DD)
            if (goal.target_date) {
                const date = new Date(goal.target_date);
                const formattedDate = date.toISOString().split('T')[0];
                document.getElementById('editGoalTargetDate').value = formattedDate;
            } else {
                document.getElementById('editGoalTargetDate').value = '';
            }

            // Set the icon
            const icon = goal.icon || 'piggy-bank';
            document.getElementById('editGoalIcon').value = icon;

            // Clear any previous errors
            document.getElementById('editGoalError').style.display = 'none';

            // Open the edit modal
            const modal = new bootstrap.Modal(document.getElementById('editGoalModal'));
            modal.show();

            // Select the correct icon after modal is shown
            setTimeout(() => {
                const iconPicker = document.getElementById('editGoalIconPicker');
                if (iconPicker) {
                    iconPicker.querySelectorAll('.icon-option').forEach(opt => opt.classList.remove('selected'));
                    const selectedIcon = iconPicker.querySelector(`[data-icon="${icon}"]`);
                    if (selectedIcon) {
                        selectedIcon.classList.add('selected');
                    }
                }
            }, 100);
        }

        async function saveGoalEdit() {
            const nameInput = document.getElementById('editGoalName');
            const amountInput = document.getElementById('editGoalAmount');
            const targetDateInput = document.getElementById('editGoalTargetDate');
            const iconInput = document.getElementById('editGoalIcon');
            const errorDiv = document.getElementById('editGoalError');

            const name = nameInput.value.trim();
            const amount = parseFloat(amountInput.value);
            const targetDate = targetDateInput.value;
            const icon = iconInput.value;

            // Validate inputs
            if (!name) {
                errorDiv.textContent = 'Please enter a goal name';
                errorDiv.style.display = 'block';
                return;
            }

            if (isNaN(amount) || amount <= 0) {
                errorDiv.textContent = 'Please enter a valid amount greater than 0';
                errorDiv.style.display = 'block';
                return;
            }

            // Validate target date if provided
            if (targetDate) {
                const target = new Date(targetDate);
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                if (target < today) {
                    errorDiv.textContent = 'Target date must be in the future';
                    errorDiv.style.display = 'block';
                    return;
                }
            }

            try {
                const goalData = { name, amount, icon };
                if (targetDate) {
                    goalData.target_date = targetDate;
                }

                const response = await fetch(`/api/goals/${editingGoal.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(goalData)
                });

                const data = await response.json();
                if (data.success) {
                    // Close the edit modal
                    const modal = bootstrap.Modal.getInstance(document.getElementById('editGoalModal'));
                    modal.hide();

                    // Refresh goals list
                    await fetchGoals();
                    renderGoalsList();

                    // Reload milestone chart with updated goals
                    await reloadMilestones();
                } else {
                    errorDiv.textContent = data.error || 'Failed to update goal';
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('Error updating goal:', error);
                errorDiv.textContent = 'Error updating goal';
                errorDiv.style.display = 'block';
            }
        }
    </script>

    <!-- Goals Management Modal -->
    <div class="modal fade" id="goalsModal" tabindex="-1" aria-labelledby="goalsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="goalsModalLabel">Manage Financial Goals</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <h6>Current Goals <span id="goalsType"></span></h6>
                        <div class="list-group" id="goalsList"></div>
                    </div>

                    <hr>

                    <div class="mb-3">
                        <h6>Add Custom Goal</h6>
                        <div class="alert alert-info">
                            <small>
                                <i class="fas fa-info-circle"></i>
                                Adding a custom goal will replace the predefined goals. All your custom goals will be used as milestones.
                            </small>
                        </div>
                        <div id="goalError" class="alert alert-danger" style="display: none;"></div>
                        <div class="row">
                            <div class="col-md-4">
                                <label for="goalName" class="form-label">Goal Name</label>
                                <input type="text" class="form-control" id="goalName" placeholder="e.g., New Car">
                            </div>
                            <div class="col-md-4">
                                <label for="goalAmount" class="form-label">Amount ($)</label>
                                <input type="number" class="form-control" id="goalAmount" placeholder="e.g., 25000" step="100">
                            </div>
                            <div class="col-md-4">
                                <label for="goalTargetDate" class="form-label">Target Date</label>
                                <input type="date" class="form-control" id="goalTargetDate">
                            </div>
                        </div>
                        <div class="mt-3">
                            <label class="form-label">Choose Icon</label>
                            <div id="goalIconPicker" class="icon-picker">
                                <div class="icon-option" data-icon="piggy-bank"><i class="fas fa-piggy-bank"></i></div>
                                <div class="icon-option" data-icon="motorcycle"><i class="fas fa-motorcycle"></i></div>
                                <div class="icon-option" data-icon="plane"><i class="fas fa-plane"></i></div>
                                <div class="icon-option" data-icon="car"><i class="fas fa-car"></i></div>
                                <div class="icon-option" data-icon="home"><i class="fas fa-home"></i></div>
                                <div class="icon-option" data-icon="graduation-cap"><i class="fas fa-graduation-cap"></i></div>
                                <div class="icon-option" data-icon="ring"><i class="fas fa-ring"></i></div>
                                <div class="icon-option" data-icon="laptop"><i class="fas fa-laptop"></i></div>
                                <div class="icon-option" data-icon="shopping-bag"><i class="fas fa-shopping-bag"></i></div>
                                <div class="icon-option" data-icon="gamepad"><i class="fas fa-gamepad"></i></div>
                                <div class="icon-option" data-icon="camera"><i class="fas fa-camera"></i></div>
                                <div class="icon-option" data-icon="bicycle"><i class="fas fa-bicycle"></i></div>
                            </div>
                            <input type="hidden" id="goalIcon" value="piggy-bank">
                        </div>
                        <button class="btn btn-primary mt-3" onclick="addGoal()">
                            <i class="fas fa-plus"></i> Add Goal
                        </button>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Goal Modal -->
    <div class="modal fade" id="editGoalModal" tabindex="-1" aria-labelledby="editGoalModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="editGoalModalLabel">Edit Goal</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="editGoalError" class="alert alert-danger" style="display: none;"></div>
                    <div class="mb-3">
                        <label for="editGoalName" class="form-label">Goal Name</label>
                        <input type="text" class="form-control" id="editGoalName">
                    </div>
                    <div class="mb-3">
                        <label for="editGoalAmount" class="form-label">Amount ($)</label>
                        <input type="number" class="form-control" id="editGoalAmount" step="100">
                    </div>
                    <div class="mb-3">
                        <label for="editGoalTargetDate" class="form-label">Target Date</label>
                        <input type="date" class="form-control" id="editGoalTargetDate">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Choose Icon</label>
                        <div id="editGoalIconPicker" class="icon-picker">
                            <div class="icon-option" data-icon="piggy-bank"><i class="fas fa-piggy-bank"></i></div>
                            <div class="icon-option" data-icon="motorcycle"><i class="fas fa-motorcycle"></i></div>
                            <div class="icon-option" data-icon="plane"><i class="fas fa-plane"></i></div>
                            <div class="icon-option" data-icon="car"><i class="fas fa-car"></i></div>
                            <div class="icon-option" data-icon="home"><i class="fas fa-home"></i></div>
                            <div class="icon-option" data-icon="graduation-cap"><i class="fas fa-graduation-cap"></i></div>
                            <div class="icon-option" data-icon="ring"><i class="fas fa-ring"></i></div>
                            <div class="icon-option" data-icon="laptop"><i class="fas fa-laptop"></i></div>
                            <div class="icon-option" data-icon="shopping-bag"><i class="fas fa-shopping-bag"></i></div>
                            <div class="icon-option" data-icon="gamepad"><i class="fas fa-gamepad"></i></div>
                            <div class="icon-option" data-icon="camera"><i class="fas fa-camera"></i></div>
                            <div class="icon-option" data-icon="bicycle"><i class="fas fa-bicycle"></i></div>
                        </div>
                        <input type="hidden" id="editGoalIcon" value="piggy-bank">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="saveGoalEdit()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <style>
        .icon-picker {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .icon-option {
            width: 50px;
            height: 50px;
            border: 2px solid #ddd;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 24px;
            color: #495057;
        }
        .icon-option:hover {
            border-color: #4285f4;
            background: #f8f9fa;
            transform: scale(1.1);
        }
        .icon-option.selected {
            border-color: #4285f4;
            background: #e3f2fd;
            color: #4285f4;
            box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.2);
        }
        .goal-icon-display {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            flex-shrink: 0;
        }
        .goal-icon-display i {
            color: white;
            font-size: 20px;
        }
    </style>

    <script>
        // Icon picker functionality
        function setupIconPicker(pickerSelector, hiddenInputSelector) {
            const picker = document.querySelector(pickerSelector);
            const hiddenInput = document.querySelector(hiddenInputSelector);

            if (!picker || !hiddenInput) return;

            // Select first icon by default
            const firstIcon = picker.querySelector('.icon-option');
            if (firstIcon) {
                firstIcon.classList.add('selected');
            }

            picker.querySelectorAll('.icon-option').forEach(option => {
                option.addEventListener('click', function() {
                    // Remove selection from all
                    picker.querySelectorAll('.icon-option').forEach(opt => opt.classList.remove('selected'));
                    // Add selection to clicked
                    this.classList.add('selected');
                    // Update hidden input
                    hiddenInput.value = this.getAttribute('data-icon');
                });
            });
        }

        // Setup both icon pickers when modal opens
        document.getElementById('goalsModal').addEventListener('shown.bs.modal', function() {
            setupIconPicker('#goalIconPicker', '#goalIcon');
        });

        document.getElementById('editGoalModal').addEventListener('shown.bs.modal', function() {
            setupIconPicker('#editGoalIconPicker', '#editGoalIcon');
        });
    </script>
</body>
</html>